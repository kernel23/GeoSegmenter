<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geo-Segmenter Tool (Advanced Prompts)</title>
    <!-- 
        DEVELOPMENT NOTE: The Tailwind CSS CDN (below) is used for simplicity in this standalone HTML file.
        For production environments or more complex projects, Tailwind CSS should be installed
        as a PostCSS plugin or using the Tailwind CLI.
        See: https://tailwindcss.com/docs/installation
    -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" xintegrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        // This function is called by the Google Maps API script once it's loaded
        window.initMapState = function() {
            // This function will be more fully defined in the main script block later,
            // but it needs to exist globally when the Maps API script loads.
            // We will set a flag that the main script can check.
            window.googleMapsApiLoaded = true;
            if (window.initializeGoogleMap && typeof window.initializeGoogleMap === 'function' && window.imageSourceTypeSelect && window.imageSourceTypeSelect.value === '3dmap') {
                 window.initializeGoogleMap();
            }
        };
    </script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAR8OiUhNkgpC00uzYRzDgawzKDlky4ye0&callback=initMapState&loading=async"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; overflow: hidden; }
        #google-map-container {
            height: 100%;
            width: 100%;
            background-color: #e0e0e0; /* Placeholder background */
        }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f5f9; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 3px; }
        .dark .custom-scrollbar::-webkit-scrollbar-track { background: #334155; } /* Dark mode scrollbar track */
        .dark .custom-scrollbar::-webkit-scrollbar-thumb { background: #64748b; } /* Dark mode scrollbar thumb */

        #canvas-container {
            cursor: grab;
            background-color: #000000; /* Black background */
        }
        .dark #canvas-container {
            background-color: #000000; /* Dark background for dark mode */
        }

        #canvas-container.panning { cursor: grabbing; }
        #canvas-container.segmenting-point { cursor: copy; }
        #canvas-container.segmenting-box { cursor: crosshair; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3b82f6; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        .dark .loader { border-color: #4b5563; border-top-color: #60a5fa; } /* Dark mode loader */
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .status-dot { height: 10px; width: 10px; border-radius: 50%; display: inline-block; animation: pulse 2s infinite; }
        .status-dot.red { background-color: #ef4444; }
        .status-dot.green { background-color: #22c55e; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .radio-label input:checked + .radio-bg { background-color: #4f46e5; border-color: #4f46e5; }
        .radio-label input:checked + .radio-bg span{ transform: scale(1); }
        .polygon-item:hover { background-color: #eef2ff !important; border-color: #4338ca !important; }
        .dark .polygon-item:hover { background-color: #312e81 !important; border-color: #a5b4fc !important;}
        .zoom-btn {
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .dark .zoom-btn { background-color: #374151; color: #e5e7eb; }
        .dark .zoom-btn:hover { background-color: #4b5563; }

        /* New style for selected-for-inspection */
        .selected-for-inspection {
            background-color: #dbeafe !important; /* Tailwind blue-100 */
            border-color: #60a5fa !important; /* Tailwind blue-400 */
            /* box-shadow: 0 0 0 2px #3b82f6; /* Optional: ring effect */
        }
        .dark .selected-for-inspection {
            background-color: #2563eb !important; /* Tailwind blue-600 */
            border-color: #93c5fd !important; /* Tailwind blue-300 */
            /* box-shadow: 0 0 0 2px #60a5fa; */
        }

        /* Basic Dark Theme Styles */
        .dark body { background-color: #1f2937; color: #d1d5db; }
        .dark aside { background-color: #374151; border-r-color: #4b5563; }
        .dark header { border-b-color: #4b5563; }
        .dark h1, .dark h2, .dark .font-semibold, .dark .font-bold { color: #f3f4f6; }
        .dark .text-slate-500 { color: #9ca3af; }
        .dark .text-slate-700 { color: #d1d5db; }
        .dark .text-slate-800 { color: #e5e7eb; }
        .dark .text-slate-900 { color: #f9fafb; }
        .dark input[type="text"], .dark select {
            background-color: #4b5563;
            border-color: #6b7280;
            color: #e5e7eb;
        }
        .dark input[type="text"]::placeholder { color: #9ca3af; }
        .dark .bg-blue-50 { background-color: #1e3a8a; } /* Adjusted for dark theme */
        .dark .border-blue-200 { border-color: #3b82f6; }
        .dark .text-blue-800 { color: #bfdbfe; }
        .dark .bg-slate-50 { background-color: #4b5563; }
        .dark .border-slate-200 { border-color: #6b7280; }
        .dark .radio-label { border-color: #6b7280; }
        .dark .radio-label input:checked + .radio-bg { background-color: #6366f1; border-color: #6366f1; }
        .dark .polygon-item { background-color: #4b5563; border-color: #6b7280; }
        .dark footer { border-t-color: #4b5563; }
        .dark #canvas-placeholder { color: #9ca3af; }
        .dark #loader-overlay { background-color: rgba(31, 41, 55, 0.75); } /* Darker overlay */
        .dark .text-indigo-600 { color: #a5b4fc; }
        .dark .hover\:bg-indigo-100:hover { background-color: #312e81; }
        .dark .text-red-600 { color: #fca5a5; }
        .dark .hover\:bg-red-100:hover { background-color: #7f1d1d; }
        .dark .bg-indigo-50 { background-color: #312e81; }
        .dark .ring-indigo-500 { ring-color: #a5b4fc; }

        /* Styles for drag-and-drop */
        .layer-item.dragging {
            opacity: 0.5;
            background-color: #e0e7ff; /* Tailwind indigo-100 */
        }
        .dark .layer-item.dragging {
            background-color: #3730a3; /* Tailwind indigo-800 */
        }
        .layer-item.drag-over-target {
            border-top: 2px dashed #4f46e5; /* Tailwind indigo-600 */
        }
        .dark .layer-item.drag-over-target {
            border-top: 2px dashed #a5b4fc; /* Tailwind indigo-300 */
        }
    </style>
    <script>
        // Tailwind dark mode configuration
        tailwind.config = {
            darkMode: 'class', // or 'media' if you prefer system setting
        }
    </script>
</head>
<body class="bg-slate-100 text-slate-800 flex flex-col h-screen">
    <!-- Global Header -->
    <header class="bg-slate-800 dark:bg-slate-900 text-white p-3 flex items-center justify-between shadow-md z-20">
        <div class="flex items-center">
            <img id="global-logo-image" src="https://firebasestorage.googleapis.com/v0/b/seed-request-app.firebasestorage.app/o/background%2FChatGPT%20Image%20Jun%2028%2C%202025%2C%2012_51_51%20PM.png?alt=media&token=79b9bd81-925a-4552-894d-74c0e2f0b93e" alt="Logo" class="h-8 w-8 mr-3">
            <h1 class="text-xl font-bold">Geo-Segmenter</h1>
        </div>
        <!-- Optional: Add other global header items here, like user profile, help, etc. -->
    </header>

    <div id="app-container" class="flex flex-grow w-screen overflow-hidden">
        <!-- Left Sidebar for Controls -->
        <aside id="left-sidebar" class="w-full md:w-80 bg-white border-r border-slate-200 flex flex-col shadow-lg z-10 dark:bg-slate-800 dark:border-slate-700 transition-all duration-300 ease-in-out">
            <header class="p-4 border-b border-slate-200 dark:border-slate-700 flex justify-between items-center">
                <h1 id="left-sidebar-title" class="text-xl font-bold text-slate-900 dark:text-slate-100">Controls</h1>
                <button id="toggle-left-sidebar-btn" class="p-1 rounded-md hover:bg-slate-200 dark:hover:bg-slate-700">
                    <svg id="left-sidebar-icon" class="w-6 h-6 text-slate-600 dark:text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                </button>
            </header>
            <div id="left-sidebar-content" class="p-4 space-y-4 flex-grow overflow-y-auto custom-scrollbar">
                <div>
                    <label for="image-source-type-select" class="block text-sm font-medium text-slate-700 mb-1 dark:text-slate-300">Select Image Source</label>
                    <select id="image-source-type-select" class="w-full px-3 py-2 border border-slate-300 rounded-md shadow-sm text-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200">
                        <option value="orthophoto">Orthophoto (Local Files)</option>
                        <option value="satellite">Satellite Image (Google Earth Engine)</option>
                        <option value="3dmap">3D Map View (Snapshot for Segmentation)</option>
                    </select>
                </div>

                <div id="orthophoto-config-section" class="p-3 bg-blue-50 border border-blue-200 rounded-md dark:bg-slate-700 dark:border-blue-500">
                    <p class="text-sm font-semibold text-blue-800 mb-2 dark:text-blue-300">Load Orthophoto</p>
                    <div class="space-y-3">
                       <div>
                           <label for="image-path" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Full Path to Orthophoto</label>
                           <input type="text" id="image-path" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200" placeholder="e.g., C:\data\my_ortho.tif">
                       </div>
                       <div>
                           <label for="worldfile-path" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Full Path to World File</label>
                           <input type="text" id="worldfile-path" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200" placeholder="e.g., C:\data\my_ortho.tfw">
                       </div>
                       <div>
                           <label for="resolution-select" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Processing Resolution</label>
                           <select id="resolution-select" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200">
                               <option value="original">Original</option>
                               <option value="8k">8K</option>
                               <option value="4k">4K</option>
                               <option value="2k">2K</option>
                               <option value="1080p">1080p</option>
                           </select>
                       </div>
                    </div>
                     <button id="process-files-btn" class="w-full mt-3 px-4 py-2 bg-indigo-600 text-white rounded-md font-semibold hover:bg-indigo-700 dark:bg-indigo-500 dark:hover:bg-indigo-600">Load Local Files</button>
                </div>

                <div id="satellite-config-section" class="p-3 bg-green-50 border border-green-200 rounded-md dark:bg-slate-700 dark:border-green-500 hidden">
                    <p class="text-sm font-semibold text-green-800 mb-2 dark:text-green-300">Load Satellite Image from Google Earth Engine</p>
                    <p class="text-xs text-slate-500 mb-2 dark:text-slate-400">Ensure you have authenticated via 'earthengine authenticate' in your terminal.</p>
                    <div class="space-y-3">
                        <div>
                            <label for="ee-image-id-input" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Earth Engine Image ID</label>
                           <input type="text" id="ee-image-id-input" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200" placeholder="e.g., LANDSAT/LC08/C02/T1_L2/LC08_044034_20200707">
                       </div>
                       <div class="grid grid-cols-2 gap-2">
                           <div>
                               <label for="ee-min-lon" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Min Lon</label>
                               <input type="number" step="any" id="ee-min-lon" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200" placeholder="-122.5">
                           </div>
                           <div>
                               <label for="ee-min-lat" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Min Lat</label>
                               <input type="number" step="any" id="ee-min-lat" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200" placeholder="37.7">
                           </div>
                           <div>
                               <label for="ee-max-lon" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Max Lon</label>
                               <input type="number" step="any" id="ee-max-lon" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200" placeholder="-122.3">
                           </div>
                           <div>
                               <label for="ee-max-lat" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Max Lat</label>
                               <input type="number" step="any" id="ee-max-lat" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200" placeholder="37.8">
                           </div>
                       </div>
                       <div>
                           <label for="ee-bands-input" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Bands (RGB, comma-sep.)</label>
                           <input type="text" id="ee-bands-input" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200" placeholder="B4,B3,B2">
                       </div>
                       <div class="grid grid-cols-2 gap-2">
                            <div>
                               <label for="ee-date-start" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Start Date (opt.)</label>
                               <input type="date" id="ee-date-start" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200">
                           </div>
                           <div>
                               <label for="ee-date-end" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">End Date (opt.)</label>
                               <input type="date" id="ee-date-end" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200">
                           </div>
                       </div>
                        <div class="grid grid-cols-2 gap-2">
                           <div>
                               <label for="ee-vis-min" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Vis Min (opt.)</label>
                               <input type="number" step="any" id="ee-vis-min" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200" placeholder="e.g., 0">
                           </div>
                           <div>
                               <label for="ee-vis-max" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Vis Max (opt.)</label>
                               <input type="number" step="any" id="ee-vis-max" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200" placeholder="e.g., 3000 or 0.3">
                           </div>
                        </div>
                        <div>
                           <label for="ee-resolution-select" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Processing Resolution</label>
                           <select id="ee-resolution-select" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200">
                               <option value="original">Original (EE fetched)</option>
                               <option value="8k">8K</option>
                               <option value="4k">4K</option>
                               <option value="2k">2K</option>
                               <option value="1080p">1080p</option>
                           </select>
                       </div>
                    </div>
                     <button id="load-ee-image-btn" class="w-full mt-3 px-4 py-2 bg-green-600 text-white rounded-md font-semibold hover:bg-green-700 dark:bg-green-500 dark:hover:bg-green-600">Load from Earth Engine</button>
                </div>

                <div id="snapshot-controls-section" class="p-3 bg-purple-50 border border-purple-200 rounded-md dark:bg-slate-700 dark:border-purple-500 hidden space-y-3">
                    <div>
                        <p class="text-sm font-semibold text-purple-800 mb-2 dark:text-purple-300">3D Map Navigation & Capture</p>
                        <p class="text-xs text-slate-500 mb-2 dark:text-slate-400">Navigate the 3D map to your desired view, then capture it for segmentation.</p>
                        <button id="capture-view-btn" class="w-full mt-2 px-4 py-2 bg-purple-600 text-white rounded-md font-semibold hover:bg-purple-700 dark:bg-purple-500 dark:hover:bg-purple-600">Capture View for Segmentation</button>
                    </div>
                    <!-- GCP Management Section -->
                    <div id="gcp-management-section" class="p-3 bg-indigo-50 border border-indigo-200 rounded-md dark:bg-slate-700 dark:border-indigo-500">
                        <p class="text-sm font-semibold text-indigo-800 mb-2 dark:text-indigo-300">Manual Georeferencing (GCPs)</p>
                        <p id="gcp-instructions" class="text-xs text-slate-500 mb-2 dark:text-slate-400">Optionally, place 4 Ground Control Points (GCPs) on the map before capturing to georeference the snapshot.</p>
                        <button id="start-gcp-placement-btn" class="w-full px-4 py-2 bg-indigo-600 text-white rounded-md font-semibold hover:bg-indigo-700 dark:bg-indigo-500 dark:hover:bg-indigo-600">Start GCP Placement</button>
                        <div id="gcp-info-panel" class="hidden mt-2 space-y-2 text-xs">
                            <p id="gcp-placement-status" class="font-medium text-indigo-700 dark:text-indigo-300">Click on the map to place GCP #1...</p>
                            <div id="gcp-coordinates-display" class="space-y-1"></div>
                            <div class="flex space-x-2">
                                <button id="clear-gcps-btn" class="w-full px-3 py-1 bg-red-600 text-white rounded-md font-semibold hover:bg-red-700 dark:bg-red-500 dark:hover:bg-red-600">Clear GCPs</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="segment-controls" class="p-3 bg-slate-50 rounded-md border border-slate-200 text-sm text-slate-600 hidden dark:bg-slate-700 dark:border-slate-600 dark:text-slate-300">
                    <p class="font-semibold mb-2 text-slate-800 dark:text-slate-200">Step 2: Create a Prompt</p>
                    <div class="grid grid-cols-2 gap-2 mb-3">
                        <label class="radio-label flex items-center p-2 rounded-md border-2 border-slate-200 cursor-pointer dark:border-slate-600">
                            <input type="radio" name="segment-mode" value="point" class="hidden" checked>
                             <div class="radio-bg w-5 h-5 mr-2 rounded-full border-2 border-slate-400 flex items-center justify-center transition-all dark:border-slate-500">
                                <span class="w-2.5 h-2.5 rounded-full bg-white transform scale-0 transition-transform"></span>
                            </div>
                            <span class="font-medium text-slate-700 dark:text-slate-300">Points</span>
                        </label>
                        <label class="radio-label flex items-center p-2 rounded-md border-2 border-slate-200 cursor-pointer dark:border-slate-600">
                            <input type="radio" name="segment-mode" value="box" class="hidden">
                             <div class="radio-bg w-5 h-5 mr-2 rounded-full border-2 border-slate-400 flex items-center justify-center transition-all dark:border-slate-500">
                                <span class="w-2.5 h-2.5 rounded-full bg-white transform scale-0 transition-transform"></span>
                            </div>
                            <span class="font-medium text-slate-700 dark:text-slate-300">Box</span>
                        </label>
                        <label class="radio-label flex items-center p-2 rounded-md border-2 border-slate-200 cursor-pointer dark:border-slate-600">
                            <input type="radio" name="segment-mode" value="draw_polygon" class="hidden">
                             <div class="radio-bg w-5 h-5 mr-2 rounded-full border-2 border-slate-400 flex items-center justify-center transition-all dark:border-slate-500">
                                <span class="w-2.5 h-2.5 rounded-full bg-white transform scale-0 transition-transform"></span>
                            </div>
                            <span class="font-medium text-slate-700 dark:text-slate-300">Draw Polygon</span>
                        </label>
                        <label class="radio-label flex items-center p-2 rounded-md border-2 border-slate-200 cursor-pointer dark:border-slate-600">
                            <input type="radio" name="segment-mode" value="select" class="hidden">
                             <div class="radio-bg w-5 h-5 mr-2 rounded-full border-2 border-slate-400 flex items-center justify-center transition-all dark:border-slate-500">
                                <span class="w-2.5 h-2.5 rounded-full bg-white transform scale-0 transition-transform"></span>
                            </div>
                            <span class="font-medium text-slate-700 dark:text-slate-300">Select</span>
                        </label>
                    </div>
                    <p id="point-instructions" class="text-xs text-slate-500 mb-3 dark:text-slate-400">Left-click for a positive prompt, Right-click for a negative prompt. Segmentation will run on each click.</p>
                    <p id="box-instructions" class="text-xs text-slate-500 mb-3 hidden dark:text-slate-400">Click and drag to draw a bounding box. Click 'Segment' to process.</p>
                    <p id="draw-polygon-instructions" class="text-xs text-slate-500 mb-3 hidden dark:text-slate-400">Left-click to add points. Right-click (min 3 points) to finish. Ctrl/Cmd+Left-click to delete last point. Esc to cancel.</p>
                    <p id="select-instructions" class="text-xs text-slate-500 mb-3 hidden dark:text-slate-400">Click on a polygon on the map to select it. Selected polygons will be highlighted.</p>
                    <div id="sam-prompt-buttons" class="flex space-x-2">
                        <button id="segment-btn" class="w-full px-4 py-2 bg-green-600 text-white rounded-md font-semibold hover:bg-green-700 dark:bg-green-500 dark:hover:bg-green-600">Segment</button>
                        <button id="clear-prompts-btn" class="w-full px-4 py-2 bg-slate-600 text-white rounded-md font-semibold hover:bg-slate-700 dark:bg-slate-500 dark:hover:bg-slate-600">Clear</button>
                    </div>
                    <div id="edit-mode-buttons" class="flex space-x-2 mt-2 hidden">
                        <button id="save-edits-btn" class="w-full px-4 py-2 bg-blue-600 text-white rounded-md font-semibold hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600">Save Edits</button>
                        <button id="cancel-edits-btn" class="w-full px-4 py-2 bg-gray-600 text-white rounded-md font-semibold hover:bg-gray-700 dark:bg-gray-500 dark:hover:bg-gray-600">Cancel Edits</button>
                    </div>
                    <p id="edit-mode-instructions" class="text-xs text-slate-500 mt-3 hidden dark:text-slate-400">
                        <b>Editing Polygon:</b> Drag vertices to move. Shift+Click edge to add new vertex. Ctrl/Cmd+Click vertex to delete. Esc to save & exit.
                    </p>
                </div>

                <!-- Polygon Stash Management Section -->
                <div id="stash-management-section" class="p-3 bg-amber-50 border border-amber-200 rounded-md dark:bg-slate-700 dark:border-amber-500">
                    <p class="text-sm font-semibold text-amber-800 mb-2 dark:text-amber-300">Polygon Stash Management</p>
                    <button id="stash-polygons-btn" class="w-full mt-1 px-4 py-2 bg-amber-600 text-white rounded-md font-semibold hover:bg-amber-700 dark:bg-amber-500 dark:hover:bg-amber-600">Stash Current Polygons & New Capture</button>
                    <div class="mt-3">
                        <label for="stashed-sets-dropdown" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Stashed Sets:</label>
                        <select id="stashed-sets-dropdown" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200">
                            <option value="">-- No stashed sets --</option>
                        </select>
                    </div>
                    <div class="flex space-x-2 mt-2">
                        <button id="load-stashed-btn" disabled class="w-full px-4 py-2 bg-sky-600 text-white rounded-md font-semibold hover:bg-sky-700 dark:bg-sky-500 dark:hover:bg-sky-600 disabled:bg-slate-400 dark:disabled:bg-slate-600">Load Selected</button>
                        <button id="delete-stashed-btn" disabled class="w-full px-4 py-2 bg-red-600 text-white rounded-md font-semibold hover:bg-red-700 dark:bg-red-500 dark:hover:bg-red-600 disabled:bg-slate-400 dark:disabled:bg-slate-600">Delete Selected</button>
                    </div>
                </div>

                <!-- External Layer Loading Section -->
                <div id="external-layer-section" class="p-3 bg-teal-50 border border-teal-200 rounded-md dark:bg-slate-700 dark:border-teal-500">
                    <p class="text-sm font-semibold text-teal-800 mb-2 dark:text-teal-300">Load External Layer</p>
                    <div class="space-y-3">
                        <div>
                            <label for="geojson-file-input" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Upload Layer File (.geojson, .json, .zip)</label>
                            <input type="file" id="geojson-file-input" accept=".geojson,.json,application/json,.zip" class="w-full text-sm text-slate-500 dark:text-slate-300
                                file:mr-4 file:py-2 file:px-4
                                file:rounded-full file:border-0
                                file:text-sm file:font-semibold
                                file:bg-teal-50 file:text-teal-700
                                hover:file:bg-teal-100 dark:file:bg-teal-700 dark:file:text-teal-200 dark:hover:file:bg-teal-600
                            "/>
                        </div>
                        <div>
                            <label for="geojson-text-input" class="block text-xs font-medium text-slate-700 mb-1 dark:text-slate-300">Or Paste GeoJSON Text</label>
                            <textarea id="geojson-text-input" rows="3" class="w-full px-2 py-1 border border-slate-300 rounded-md shadow-sm text-sm dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200" placeholder="Paste GeoJSON content here..."></textarea>
                        </div>
                    </div>
                    <button id="load-external-layer-btn" class="w-full mt-3 px-4 py-2 bg-teal-600 text-white rounded-md font-semibold hover:bg-teal-700 dark:bg-teal-500 dark:hover:bg-teal-600">Load External Layer</button>
                </div>
            </div>
            <!-- Download button removed from here -->
        </aside>

        <!-- Main Canvas Area -->
        <main id="main-content-area" class="flex-grow flex items-center justify-center relative overflow-hidden">
            <!-- Container for existing 2D canvas and its controls -->
            <div id="canvas-container" class="w-full h-full flex items-center justify-center relative">
                <canvas id="main-canvas" class="rounded-md shadow-inner"></canvas>
                <div id="zoom-controls-container" class="absolute bottom-4 right-4 flex flex-col space-y-2 hidden">
                    <button id="zoom-in-btn" class="zoom-btn w-10 h-10 bg-white rounded-full text-slate-700 text-2xl font-bold flex items-center justify-center hover:bg-slate-100 transition-colors dark:bg-slate-700 dark:text-slate-200 dark:hover:bg-slate-600">+</button>
                    <button id="zoom-out-btn" class="zoom-btn w-10 h-10 bg-white rounded-full text-slate-700 text-2xl font-bold flex items-center justify-center hover:bg-slate-100 transition-colors dark:bg-slate-700 dark:text-slate-200 dark:hover:bg-slate-600">-</button>
                </div>
                <div id="canvas-placeholder" class="text-center text-slate-500 dark:text-slate-400">
                    <p class="text-2xl mb-2">🖼️</p>
                    <p class="font-semibold">Select an image source and load data.</p>
                </div>
            </div>

            <!-- Container for Google Map -->
            <div id="google-map-container" class="w-full h-full hidden">
                <!-- Google Map will be initialized here by JavaScript -->
            </div>

            <div id="loader-overlay" class="absolute inset-0 bg-white bg-opacity-75 flex flex-col items-center justify-center hidden z-20 dark:bg-slate-800 dark:bg-opacity-75">
                <div class="loader"></div>
                <p class="mt-4 font-semibold text-slate-700 dark:text-slate-200">Processing...</p>
            </div>
        </main>

        <!-- Right Sidebar for Polygon List -->
        <aside id="right-sidebar" class="w-full md:w-80 bg-white border-l border-slate-200 flex flex-col shadow-lg z-10 dark:bg-slate-800 dark:border-slate-700 transition-all duration-300 ease-in-out">
            <header class="p-4 border-b border-slate-200 dark:border-slate-700 flex justify-between items-center">
                <h2 id="right-sidebar-title" class="text-lg font-semibold text-slate-800 dark:text-slate-100">Layers</h2>
                <button id="toggle-right-sidebar-btn" class="p-1 rounded-md hover:bg-slate-200 dark:hover:bg-slate-700">
                    <svg id="right-sidebar-icon" class="w-6 h-6 text-slate-600 dark:text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg> <!-- Default to right arrow, implying content is to the left -->
                </button>
            </header>
            <div id="right-sidebar-content" class="flex-grow p-4 overflow-y-auto custom-scrollbar">
                <p id="layer-pane-instructions" class="text-xs text-slate-500 dark:text-slate-400 mb-2">Manage layers. Double-click editable polygons on map to edit.</p>
                <ul id="layer-list" class="space-y-2"></ul> <!-- Renamed from polygon-list -->
            </div>
            <div class="p-4 border-t border-slate-200 dark:border-slate-700 space-y-2">
                <button id="download-btn" disabled class="w-full inline-flex items-center justify-center px-4 py-2 bg-green-600 text-white rounded-md shadow-sm font-semibold transition-colors disabled:bg-slate-300 disabled:cursor-not-allowed hover:bg-green-700 dark:bg-green-500 dark:hover:bg-green-600 dark:disabled:bg-slate-600">
                   <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                   Download GeoJSON
               </button>
               <button id="download-shapefile-btn" disabled class="w-full inline-flex items-center justify-center px-4 py-2 bg-blue-600 text-white rounded-md shadow-sm font-semibold transition-colors disabled:bg-slate-300 disabled:cursor-not-allowed hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 dark:disabled:bg-slate-600">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                    Download Shapefile
                </button>
                <button id="download-gcp-btn" disabled class="w-full inline-flex items-center justify-center px-4 py-2 bg-teal-600 text-white rounded-md shadow-sm font-semibold transition-colors disabled:bg-slate-300 disabled:cursor-not-allowed hover:bg-teal-700 dark:bg-teal-500 dark:hover:bg-teal-600 dark:disabled:bg-slate-600">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                    Download GCP File
                </button>
           </div>
        </aside>
    </div>

    <!-- Bottom Bar for Status, Device, and Theme -->
    <div id="bottom-bar" class="p-3 bg-white border-t border-slate-200 flex items-center justify-between text-sm shadow-md dark:bg-slate-800 dark:border-slate-700">
        <div class="flex items-center">
            <span id="status-dot" class="status-dot red mr-2"></span>
            <span id="status-text" class="text-slate-500 dark:text-slate-400">Backend: Disconnected</span>
        </div>
        <div class="flex items-center space-x-4">
            <div>
                <label for="device-select" class="sr-only">Device:</label>
                <select id="device-select" class="px-2 py-1 border border-slate-300 rounded-md shadow-sm text-xs dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200">
                    <option value="gpu">GPU</option>
                    <option value="cpu">CPU</option>
                </select>
            </div>
            <div>
                <label for="theme-select" class="sr-only">Theme:</label>
                <select id="theme-select" class="px-2 py-1 border border-slate-300 rounded-md shadow-sm text-xs dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200">
                    <option value="system">System Default</option>
                    <option value="light">Light</option>
                    <option value="dark">Dark</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Footer for Copyright -->
    <footer class="p-3 bg-slate-100 text-center text-xs text-slate-600 border-t border-slate-200 dark:bg-slate-900 dark:text-slate-400 dark:border-slate-700">
        Copyright © <span id="current-year"></span> K.Tanaval  Version 0.2.2
    </footer>

    <script>
        const BACKEND_URL = "http://127.0.0.1:5000";
        // --- DOM Elements ---
        const imagePathInput = document.getElementById('image-path');
        const worldfilePathInput = document.getElementById('worldfile-path');
        const resolutionSelect = document.getElementById('resolution-select');
        const deviceSelect = document.getElementById('device-select');
        const processBtn = document.getElementById('process-files-btn');
        const segmentControls = document.getElementById('segment-controls');
        const segmentBtn = document.getElementById('segment-btn');
        const clearPromptsBtn = document.getElementById('clear-prompts-btn');
        const mainContentArea = document.getElementById('main-content-area');
        const canvasContainer = document.getElementById('canvas-container'); // This is the div wrapping the 2D canvas
        const googleMapContainer = document.getElementById('google-map-container');
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const layerListEl = document.getElementById('layer-list'); // Renamed from polygonList
        const loaderOverlay = document.getElementById('loader-overlay');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const pointInstructions = document.getElementById('point-instructions');
        const boxInstructions = document.getElementById('box-instructions');
        const drawPolygonInstructions = document.getElementById('draw-polygon-instructions');
        const selectInstructions = document.getElementById('select-instructions'); // Added for select mode
        const downloadBtn = document.getElementById('download-btn'); // GeoJSON download
        const downloadShapefileBtn = document.getElementById('download-shapefile-btn');
        const downloadGcpBtn = document.getElementById('download-gcp-btn'); // New GCP download button
        const zoomControlsContainer = document.getElementById('zoom-controls-container');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const samPromptButtons = document.getElementById('sam-prompt-buttons');
        const editModeButtons = document.getElementById('edit-mode-buttons');
        const saveEditsBtn = document.getElementById('save-edits-btn');
        const cancelEditsBtn = document.getElementById('cancel-edits-btn');
        const editModeInstructions = document.getElementById('edit-mode-instructions');
        const themeSelect = document.getElementById('theme-select');
        const currentYearSpan = document.getElementById('current-year');
        const imageSourceTypeSelect = document.getElementById('image-source-type-select');
        const orthophotoConfigSection = document.getElementById('orthophoto-config-section');
        const satelliteConfigSection = document.getElementById('satellite-config-section');
        const snapshotControlsSection = document.getElementById('snapshot-controls-section');
        const captureViewBtn = document.getElementById('capture-view-btn');
        const stashManagementSection = document.getElementById('stash-management-section');
        const stashPolygonsBtn = document.getElementById('stash-polygons-btn');
        const stashedSetsDropdown = document.getElementById('stashed-sets-dropdown');
        const loadStashedBtn = document.getElementById('load-stashed-btn');
        const deleteStashedBtn = document.getElementById('delete-stashed-btn');
        const geojsonFileInput = document.getElementById('geojson-file-input');
        const geojsonTextInput = document.getElementById('geojson-text-input');
        const loadExternalLayerBtn = document.getElementById('load-external-layer-btn');

        // Symbology Modal DOM Elements (declared globally, assigned in init)
        let symbologyModal;
        let symbologyLayerNameSpan;
        let symbologyTypeSelect;
        let symbologySettingsSingleSymbolDiv;
        let symbologyFillColorPicker;
        let symbologyFillColorRgbaInput;
        let symbologyStrokeColorPicker;
        let symbologyStrokeColorRgbaInput;
        let symbologyStrokeWidthInput;
        let symbologyStrokeDashSelect;
        let symbologyModalCloseBtnHeader;
        let symbologyModalCancelBtn;
        let symbologyModalApplyBtn;
        let symbologyModalOkBtn;

        // GCP Management DOM Elements
        const gcpManagementSection = document.getElementById('gcp-management-section');
        const startGcpPlacementBtn = document.getElementById('start-gcp-placement-btn');
        const gcpInfoPanel = document.getElementById('gcp-info-panel');
        const gcpPlacementStatus = document.getElementById('gcp-placement-status');
        const gcpCoordinatesDisplay = document.getElementById('gcp-coordinates-display');
        const clearGcpsBtn = document.getElementById('clear-gcps-btn');


        // Earth Engine specific inputs
        const eeImageIdInput = document.getElementById('ee-image-id-input');
        const eeMinLonInput = document.getElementById('ee-min-lon');
        const eeMinLatInput = document.getElementById('ee-min-lat');
        const eeMaxLonInput = document.getElementById('ee-max-lon');
        const eeMaxLatInput = document.getElementById('ee-max-lat');
        const eeBandsInput = document.getElementById('ee-bands-input');
        const eeDateStartInput = document.getElementById('ee-date-start');
        const eeDateEndInput = document.getElementById('ee-date-end');
        const eeResolutionSelect = document.getElementById('ee-resolution-select');
        const loadEeImageBtn = document.getElementById('load-ee-image-btn');
        const eeVisMinInput = document.getElementById('ee-vis-min');
        const eeVisMaxInput = document.getElementById('ee-vis-max');

        const leftSidebar = document.getElementById('left-sidebar');
        const leftSidebarContent = document.getElementById('left-sidebar-content');
        const leftSidebarTitle = document.getElementById('left-sidebar-title');
        const toggleLeftSidebarBtn = document.getElementById('toggle-left-sidebar-btn');
        const leftSidebarIcon = document.getElementById('left-sidebar-icon');
        const rightSidebar = document.getElementById('right-sidebar');
        const rightSidebarContent = document.getElementById('right-sidebar-content');
        const rightSidebarTitle = document.getElementById('right-sidebar-title');
        const toggleRightSidebarBtn = document.getElementById('toggle-right-sidebar-btn');
        const rightSidebarIcon = document.getElementById('right-sidebar-icon');


        // --- State ---
        let isLeftSidebarCollapsed = false;
        let isRightSidebarCollapsed = false;
        let image = null;
        // let polygons = []; // Replaced by layers
        let layers = [];
        let defaultSegmentationLayerId = 'defaultSegmentationLayer';
        let transform = { x: 0, y: 0, scale: 1 };
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let isCtrlPressed = false; // Added to track Ctrl key state
        let isShiftPressed = false; // Added to track Shift key state
        let nextPolygonId = 1;
        let geoTransformParams = null;
        let fullImageShape = null; // Stores {width, height} of the original image
        let modelInputShape = null; // Stores {width, height} of the image SAM actually sees
        let highlightedPolygonId = null;
        let availableResolutions = [];
        let currentBackendDevice = '';
        let googleMap = null; // Variable to hold the Google Map instance
        let mapInitialized = false; // This will be set by initializeGoogleMap after checking window.googleMapsApiLoaded
        let stashedPolygonSets = [];
        let currentSnapshotGCPData = null; // To store GCPs for the current session
        let selectedPolygonIdForInspection = null; // For the new "Select" mode


        // --- GCP State ---
        let isGcpPlacementMode = false;
        let gcpPoints = []; // Stores {geo: latLng, marker: mapMarker}
        let gcpMapClickListener = null;

        // --- Editing State ---
        let isEditMode = false;
        let selectedPolygonForEdit = null;
        let draggedVertexIndex = null;
        let originalPolygonPoints = null; // For undo/cancel functionality
        let originalPixelPoints = null; // For undo/cancel of pixelPoints for GCP-derived polygons
        let draggedLayerId = null; // For layer reordering
        let currentSymbologyEditLayerId = null; // For symbology editor
        
        // --- Prompting State ---
        let segmentMode = 'point';
        let tempPoints = [];
        let tempBox = null;
        let isDrawingBox = false;
        let currentManualPolygonPoints = []; // For drawing new polygons
        let currentMousePos = { x: 0, y: 0 }; // For rubber-banding line

        function init() {
            // Symbology Modal DOM Elements - Moved inside init() for safety
            symbologyModal = document.getElementById('symbology-editor-modal');
            symbologyLayerNameSpan = document.getElementById('symbology-editor-layer-name');
            symbologyTypeSelect = document.getElementById('symbology-type-select');
            symbologySettingsSingleSymbolDiv = document.getElementById('symbology-settings-singleSymbol');
            symbologyFillColorPicker = document.getElementById('symbology-fill-color-picker');
            symbologyFillColorRgbaInput = document.getElementById('symbology-fill-color-rgba');
            symbologyStrokeColorPicker = document.getElementById('symbology-stroke-color-picker');
            symbologyStrokeColorRgbaInput = document.getElementById('symbology-stroke-color-rgba');
            symbologyStrokeWidthInput = document.getElementById('symbology-stroke-width');
            symbologyStrokeDashSelect = document.getElementById('symbology-stroke-dash');
            symbologyModalCloseBtnHeader = document.getElementById('symbology-editor-close-btn-header');
            symbologyModalCancelBtn = document.getElementById('symbology-editor-cancel-btn');
            symbologyModalApplyBtn = document.getElementById('symbology-editor-apply-btn');
            symbologyModalOkBtn = document.getElementById('symbology-editor-ok-btn');
            
            // Initial check if Maps API loaded before main script init
            if (window.googleMapsApiLoaded && imageSourceTypeSelect.value === '3dmap' && !googleMap) {
                initializeGoogleMap();
            }

            processBtn.addEventListener('click', processFiles);
            segmentBtn.addEventListener('click', runSegmentation);
            clearPromptsBtn.addEventListener('click', clearPrompts);
            downloadBtn.addEventListener('click', downloadGeoJSON);
            downloadShapefileBtn.addEventListener('click', downloadAsShapefile);
            downloadGcpBtn.addEventListener('click', downloadGCPFile);
            zoomInBtn.addEventListener('click', () => applyZoom(1.2));
            zoomOutBtn.addEventListener('click', () => applyZoom(0.8));
            saveEditsBtn.addEventListener('click', () => exitEditMode(true)); // true = save changes
            cancelEditsBtn.addEventListener('click', () => exitEditMode(false)); // false = discard changes
            deviceSelect.addEventListener('change', handleDeviceChange);
            themeSelect.addEventListener('change', handleThemeChange);
            toggleLeftSidebarBtn.addEventListener('click', toggleLeftSidebar);
            toggleRightSidebarBtn.addEventListener('click', toggleRightSidebar);
            loadEeImageBtn.addEventListener('click', loadEarthEngineImage);
            imageSourceTypeSelect.addEventListener('change', handleImageSourceTypeChange);
            captureViewBtn.addEventListener('click', captureAndDisplaySnapshot);
            stashPolygonsBtn.addEventListener('click', stashPolygonsAndNewCapture); // Placeholder for now
            loadStashedBtn.addEventListener('click', loadStashedSet); 
            deleteStashedBtn.addEventListener('click', deleteStashedSet); 
            loadExternalLayerBtn.addEventListener('click', loadExternalGeoJSON);
            stashedSetsDropdown.addEventListener('change', () => { // Enable/disable buttons based on selection
                const hasSelection = stashedSetsDropdown.value !== "" && stashedPolygonSets.length > 0;
                loadStashedBtn.disabled = !hasSelection;
                deleteStashedBtn.disabled = !hasSelection;
            });

            // GCP Listeners
            startGcpPlacementBtn.addEventListener('click', toggleGcpPlacementMode);
            clearGcpsBtn.addEventListener('click', clearGCPs);
            
            document.querySelectorAll('input[name="segment-mode"]').forEach(radio => {
                radio.addEventListener('change', async (e) => { // Make async as exitEditMode is async
                    if (isEditMode) await exitEditMode(true); // Save and exit if changing mode

                    segmentMode = e.target.value;
                    console.log("Switched to segmentMode:", segmentMode);

                    // Clear temporary interaction states from other modes
                    if (segmentMode !== 'point') tempPoints = [];
                    if (segmentMode !== 'box') tempBox = null;
                    if (segmentMode !== 'draw_polygon') currentManualPolygonPoints = [];
                    
                    // selectedPolygonIdForInspection = null; // Keep selection for now, user can click away or Esc

                    pointInstructions.classList.toggle('hidden', segmentMode !== 'point');
                    boxInstructions.classList.toggle('hidden', segmentMode !== 'box');
                    drawPolygonInstructions.classList.toggle('hidden', segmentMode !== 'draw_polygon');
                    selectInstructions.classList.toggle('hidden', segmentMode !== 'select');

                    // Show/hide SAM prompt buttons (Segment, Clear Prompts)
                    if (segmentMode === 'select' || segmentMode === 'draw_polygon') { // Also hide for draw_polygon as it has its own interaction
                        samPromptButtons.classList.add('hidden');
                    } else { // point, box
                        samPromptButtons.classList.remove('hidden');
                    }
                    
                    // Edit mode buttons are handled separately by enter/exitEditMode

                    if (!isEditMode) {
                        updateCursorBasedOnMode(); 
                    }
                    draw(); // Redraw to reflect cleared prompts or mode changes
                });
            });

            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove); // Already exists, will update currentMousePos
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel); // Keep wheel for zooming
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            canvas.addEventListener('dblclick', handleDoubleClick);


            window.addEventListener('keydown', (e) => {
                if (e.key === 'Control') {
                    isCtrlPressed = true;
                    if (image && !isDrawingBox && !isEditMode && segmentMode !== 'point' && segmentMode !== 'box' && draggedVertexIndex === null) {
                        canvasContainer.style.cursor = 'grabbing';
                        canvasContainer.classList.add('panning');
                    }
                }
                if (e.key === 'Shift') {
                    isShiftPressed = true;
                    if (isEditMode && selectedPolygonForEdit && draggedVertexIndex === null) {
                    }
                }
                if (e.key === 'Escape') {
                    if (isEditMode) {
                        exitEditMode(true); // Default to save changes on Escape
                    } else if (segmentMode === 'draw_polygon' && currentManualPolygonPoints.length > 0) {
                        currentManualPolygonPoints = []; // Cancel current polygon drawing
                        draw();
                        alert("Polygon drawing cancelled.");
                    } 
                    // NEW: Add Escape key for clearing inspection selection
                    else if (segmentMode === 'select' && selectedPolygonIdForInspection !== null) {
                        console.log("Clearing inspection selection via Escape key.");
                        selectedPolygonIdForInspection = null;
                        draw(); // Redraw to remove highlight from canvas
                        updateLayerPane(); // Redraw to remove highlight from list
                    }
                }
            });

            window.addEventListener('keyup', (e) => {
                if (e.key === 'Control') {
                    isCtrlPressed = false;
                    if (image && !isPanning) { // Only reset if not actively panning
                        canvasContainer.classList.remove('panning');
                        updateCursorBasedOnMode(); // Centralize cursor logic
                    }
                }
                if (e.key === 'Shift') {
                    isShiftPressed = false;
                    if (isEditMode && selectedPolygonForEdit && draggedVertexIndex === null) {
                        updateCursorBasedOnMode(); // Revert from potential 'add vertex' cursor
                    }
                }
            });

            checkBackendStatus();
            setInterval(checkBackendStatus, 5000);
            initializeTheme();
            updateCopyrightYear();

            window.addEventListener('keydown', handleTabNavigation); // Added for Tab navigation
            updateStashedSetsDropdown(); // Initial population of dropdown
            initializeLayers(); // Initialize the layers structure

            // --- Symbology Editor Event Listeners ---
            // Event delegation for "Edit Symbology" buttons in the layer pane
            layerListEl.addEventListener('click', (event) => {
                const targetButton = event.target.closest('.edit-symbology-btn');
                if (targetButton) {
                    const layerId = targetButton.dataset.layerId;
                    if (layerId) {
                        openSymbologyEditor(layerId);
                    }
                }
            });

            // Modal main action buttons
            symbologyModalOkBtn.addEventListener('click', () => {
                applySymbologyChanges();
                closeSymbologyEditor();
            });
            symbologyModalApplyBtn.addEventListener('click', () => {
                applySymbologyChanges();
            });
            symbologyModalCancelBtn.addEventListener('click', () => {
                closeSymbologyEditor();
            });
            symbologyModalCloseBtnHeader.addEventListener('click', () => { // Header 'X' button
                closeSymbologyEditor();
            });

            // Color picker and RGBA input synchronization
            symbologyFillColorPicker.addEventListener('input', () => {
                const alpha = getRgbaAlpha(symbologyFillColorRgbaInput.value); // Preserve existing alpha
                symbologyFillColorRgbaInput.value = hexToRgba(symbologyFillColorPicker.value, alpha);
            });
            symbologyFillColorRgbaInput.addEventListener('input', () => { // Or 'change' if preferred
                symbologyFillColorPicker.value = rgbaToHex(symbologyFillColorRgbaInput.value);
                 // Future: could add validation for RGBA input here
            });

            symbologyStrokeColorPicker.addEventListener('input', () => {
                const alpha = getRgbaAlpha(symbologyStrokeColorRgbaInput.value); // Preserve existing alpha
                symbologyStrokeColorRgbaInput.value = hexToRgba(symbologyStrokeColorPicker.value, alpha);
            });
            symbologyStrokeColorRgbaInput.addEventListener('input', () => {
                symbologyStrokeColorPicker.value = rgbaToHex(symbologyStrokeColorRgbaInput.value);
            });
            
            // Listener for symbology type change (placeholder for future)
            symbologyTypeSelect.addEventListener('change', () => {
                // This listener is now simpler as only 'singleSymbol' is effectively supported.
                // The UI for single symbol is always visible when the modal is open.
                // No sections need to be shown/hidden based on type selection anymore.
                console.log("Symbology type select changed. Current value (should be singleSymbol):", symbologyTypeSelect.value);
                symbologySettingsSingleSymbolDiv.classList.remove('hidden'); 
                // Ensure categorized div (if it somehow exists from old code/cache) is hidden
                const categorizedSettingsDiv = document.getElementById('symbology-settings-categorized');
                if (categorizedSettingsDiv) categorizedSettingsDiv.classList.add('hidden');
            });
            // --- End Symbology Editor Event Listeners ---
        }

        function initializeLayers() {
            layers = [{ 
                id: defaultSegmentationLayerId, 
                name: 'Segmentation Output', 
                polygons: [], 
                visible: true, 
                opacity: 1.0, 
                isExpanded: false, 
                deletable: false, 
                type: 'segmentation',
                symbology: {
                    type: 'singleSymbol', 
                    fillColor: 'rgba(0,0,255,0.4)',
                    strokeColor: 'rgba(0,0,200,1)',
                    strokeWidth: 1,
                    strokeDashArray: []
                }
            }];
            // Simplified check for default layer's symbology
             if(layers[0] && layers[0].id === defaultSegmentationLayerId && layers[0].symbology) {
                layers[0].symbology.type = 'singleSymbol'; // Ensure type is singleSymbol
                layers[0].symbology.fillColor = layers[0].symbology.fillColor || 'rgba(0,0,255,0.4)';
                layers[0].symbology.strokeColor = layers[0].symbology.strokeColor || 'rgba(0,0,200,1)';
                layers[0].symbology.strokeWidth = layers[0].symbology.strokeWidth === undefined ? 1 : layers[0].symbology.strokeWidth;
                layers[0].symbology.strokeDashArray = layers[0].symbology.strokeDashArray || [];
                // Remove categorized properties if they somehow exist
                delete layers[0].symbology.field;
                delete layers[0].symbology.categories;
                delete layers[0].symbology.defaultSymbol;
            }
        }

        async function loadExternalGeoJSON() {
            const file = geojsonFileInput.files[0];
            const text = geojsonTextInput.value.trim();
            let payloadType = null; // 'file' or 'textual_geojson'
            let dataToSend = null;

            if (file) {
                payloadType = 'file';
                dataToSend = new FormData();
                dataToSend.append('geojson_file', file); // Backend will determine if .zip or .geojson
            } else if (text) {
                try {
                    const jsonData = JSON.parse(text);
                    payloadType = 'textual_geojson';
                    dataToSend = { geojson_data: jsonData };
                } catch (e) {
                    alert(`Error parsing GeoJSON text: ${e.message}`);
                    return;
                }
            } else {
                alert("Please select a layer file (.zip, .geojson, .json) or paste GeoJSON text.");
                return;
            }

            if (!payloadType) { // Should not happen if logic above is correct
                alert("Could not determine data to load.");
                return;
            }

            loaderOverlay.classList.remove('hidden');
            loaderOverlay.querySelector('p').textContent = 'Loading external layer...';

            try {
                let response;
                if (payloadType === 'file') {
                    response = await fetch(`${BACKEND_URL}/load_external_polygons`, {
                        method: 'POST',
                        body: dataToSend // FormData
                    });
                } else { // textual_geojson
                    response = await fetch(`${BACKEND_URL}/load_external_polygons`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(dataToSend) // { geojson_data: ... }
                    });
                }

                const result = await response.json();
                if (!response.ok) throw new Error(result.error || `Failed with status ${response.status}`);

                if (result.external_polygons && result.external_polygons.length > 0) {
                    // Create a new layer for these external polygons
                    const newLayerId = 'layer_' + nextPolygonId++; // nextPolygonId is also used for polygon IDs, ensure layer IDs are distinct or manage separately
                    const layerName = file ? file.name : (text ? 'Pasted GeoJSON Layer' : 'External Layer');
                    
                    // Ensure polygon IDs within this new layer are unique globally if backend doesn't guarantee
                    // For now, assume backend IDs are fine, or that nextPolygonId usage for layers is okay
                    // The backend already tries to assign unique IDs.
                    
                    const newLayer = {
                        id: newLayerId,
                        name: layerName,
                        polygons: result.external_polygons, 
                        visible: true,
                        opacity: 1.0,
                        isExpanded: false, 
                        deletable: true,
                        type: 'external',
                        sourceFileName: file ? file.name : null,
                        mapDataGeoJson: result.geojson_for_map_data, // Store for visibility toggling
                        symbology: { 
                            type: 'singleSymbol',
                            fillColor: 'rgba(0,128,0,0.4)', // Default for external layers
                            strokeColor: 'rgba(0,100,0,1)',
                            strokeWidth: 1,
                            strokeDashArray: [5,5] 
                            // Removed field, categories, defaultSymbol
                        }
                    };

                    // Try to use the first polygon's color from backend for a more specific default for singleSymbol
                    if (result.external_polygons && result.external_polygons.length > 0 && result.external_polygons[0].color) {
                        try {
                            const firstPolyColor = result.external_polygons[0].color;
                            const colorParts = firstPolyColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([0-9.]+))?\)/);
                            if (colorParts) {
                                newLayer.symbology.fillColor = `rgba(${colorParts[1]},${colorParts[2]},${colorParts[3]},0.4)`;
                                newLayer.symbology.strokeColor = `rgba(${colorParts[1]},${colorParts[2]},${colorParts[3]},1)`;
                            }
                        } catch (e) {
                            console.warn("Could not parse color from backend for external layer default symbology", e);
                        }
                    }
                    layers.push(newLayer);
                    console.log("Newly loaded external layer (internal format):", JSON.stringify(newLayer.polygons, null, 2)); 
                    // console.log("GeoJSON for map:", JSON.stringify(result.geojson_for_map_data, null, 2));


                    // Display on Google Map if it's the active view
                    if (googleMap && imageSourceTypeSelect.value === '3dmap' && result.geojson_for_map_data) {
                        // Clear previous map.data features
                        googleMap.data.forEach(feature => {
                            googleMap.data.remove(feature);
                        });
                        // Add new features
                        googleMap.data.addGeoJson(result.geojson_for_map_data);
                        
                        // Iterate through newly added features to tag them and apply initial style
                        googleMap.data.forEach(feature => {
                            // Check if this feature was just added (e.g. by checking if it lacks our custom ID yet)
                            // This is a bit indirect. A cleaner way would be if addGeoJson returned the features.
                            // For now, we'll assume this is run right after addGeoJson and applies to all current features
                            // if we intend to style them based on the *newLayer*'s initial symbology.
                            // To be more precise, we should only style features from *this* newLayer.
                            // However, result.geojson_for_map_data IS the new layer's data.
                            
                            // Tag feature with our internal layer ID
                            feature.setProperty('geoSegmenterLayerId', newLayer.id);
                            
                            // Apply initial style based on newLayer.symbology
                            googleMap.data.overrideStyle(feature, {
                                fillColor: newLayer.symbology.fillColor,
                                strokeColor: newLayer.symbology.strokeColor,
                                strokeWeight: newLayer.symbology.strokeWidth,
                                fillOpacity: getRgbaAlpha(newLayer.symbology.fillColor),
                                strokeOpacity: getRgbaAlpha(newLayer.symbology.strokeColor),
                                clickable: false 
                            });
                        });
                        console.log("External layer added to Google Map data layer and features tagged with ID:", newLayer.id);
                    }
                    
                    updateLayerPane(); 
                    draw(); // This will draw on canvas if snapshot taken later
                    alert(result.message);
                } else {
                    alert("No valid polygons found in the external layer or an issue occurred.");
                }
                geojsonFileInput.value = ''; 
                geojsonTextInput.value = ''; 

            } catch (error) {
                console.error("Error loading external layer:", error);
                alert(`Failed to load external layer: ${error.message}`);
            } finally {
                loaderOverlay.classList.add('hidden');
            }
        }

        function deepCopy(obj) {
            try {
                return JSON.parse(JSON.stringify(obj));
            } catch (e) {
                console.error("Deep copy failed:", e, "Object was:", obj);
                return null; 
            }
        }

        function stashPolygonsAndNewCapture() {
            // Corrected condition to check the 'layers' array
            if (layers.length === 0 || layers.every(l => !l.polygons || l.polygons.length === 0)) {
                alert("No current polygons to stash.");
                return;
            }

            // const copiedPolygons = deepCopy(polygons); // Old code, removed
            // TODO: Stash/Load functionality needs to be refactored for the new layers structure.
            // For now, it might not work as expected or might only operate on the first/default layer.
            // This is a known limitation for this phase.
            // if (layers.length === 0 || layers.every(l => l.polygons.length === 0)) { // This was the intended, but the error implies the one above was active
            //    alert("No current polygons to stash.");
            //    return;
            //}

            const copiedLayers = deepCopy(layers); // Stash the whole layers structure
            if (!copiedLayers) {
                alert("Failed to copy layers for stashing. Aborting.");
                return;
            }

            let currentSourceType = imageSourceTypeSelect.value;
            if (image && image.src && image.src.startsWith('data:image/')) {
                 currentSourceType = 'snapshot';
                 if (currentSnapshotGCPData) {
                     currentSourceType = 'snapshot_georef';
                 }
            }
            // Ensure nextPolygonId is also stashed if it's part of the image context for future polygon additions
            // For now, we are not stashing nextPolygonId, so loading a stashed set might reuse IDs if new polygons are added.
            // This is a minor issue for now.

            const currentImageContext = {
                fullImageShape: deepCopy(fullImageShape),
                modelInputShape: deepCopy(modelInputShape),
                geoTransformParams: deepCopy(geoTransformParams),
                imageSrc: image ? image.src : null, 
                sourceType: currentSourceType,
                gcpData: deepCopy(currentSnapshotGCPData) 
            };

            stashedPolygonSets.push({
                name: `Set ${stashedPolygonSets.length + 1} (${copiedLayers.length} layers)`,
                data: copiedLayers, 
                imageContext: currentImageContext
            });

            // Instead of initializeLayers(), selectively clear segmentation layers
            layers.forEach(layer => {
                if (layer.type === 'segmentation' || layer.id === defaultSegmentationLayerId) {
                    layer.polygons = [];
                    // Potentially reset other layer-specific states here if needed, e.g., isExpanded for these
                    // layer.isExpanded = false; // Optional: collapse segmentation layers
                }
            });
            console.log("Cleared polygons from segmentation layers for 'New Capture'. External layers preserved.");
            
            tempPoints = [];
            tempBox = null;
            currentManualPolygonPoints = [];
            // currentSnapshotGCPData is related to the base image, so it might not need clearing here
            // unless "New Capture" always implies new GCPs for a snapshot.
            // For now, let's assume currentSnapshotGCPData persists if the base image (snapshot) isn't changed.
            // downloadGcpBtn.disabled = true; // This depends on currentSnapshotGCPData

            updateLayerPane(); 
            updateStashedSetsDropdown(); 

            segmentControls.classList.add('hidden');
            loaderOverlay.classList.add('hidden'); 

            const previousSourceTypeForViewReset = currentImageContext.sourceType;
            image = null; 
            ctx.clearRect(0, 0, canvas.width, canvas.height); 

            if (previousSourceTypeForViewReset.startsWith('snapshot') || imageSourceTypeSelect.value === '3dmap') {
                googleMapContainer.classList.remove('hidden');
                canvasContainer.classList.add('hidden');
                snapshotControlsSection.classList.remove('hidden');
                orthophotoConfigSection.classList.add('hidden');
                satelliteConfigSection.classList.add('hidden');
                imageSourceTypeSelect.value = '3dmap'; 
            } else if (previousSourceTypeForViewReset === 'orthophoto') {
                canvasContainer.classList.remove('hidden');
                document.getElementById('canvas-placeholder').classList.remove('hidden');
                googleMapContainer.classList.add('hidden');
                orthophotoConfigSection.classList.remove('hidden');
                satelliteConfigSection.classList.add('hidden');
                snapshotControlsSection.classList.add('hidden');
                imageSourceTypeSelect.value = 'orthophoto';
            } else if (previousSourceTypeForViewReset === 'satellite') {
                canvasContainer.classList.remove('hidden');
                document.getElementById('canvas-placeholder').classList.remove('hidden');
                googleMapContainer.classList.add('hidden');
                orthophotoConfigSection.classList.add('hidden');
                satelliteConfigSection.classList.remove('hidden');
                snapshotControlsSection.classList.add('hidden');
                imageSourceTypeSelect.value = 'satellite';
            } else {
                canvasContainer.classList.remove('hidden');
                document.getElementById('canvas-placeholder').classList.remove('hidden');
                googleMapContainer.classList.add('hidden');
                orthophotoConfigSection.classList.remove('hidden');
                 imageSourceTypeSelect.value = 'orthophoto';
            }

            draw(); 

            alert("Polygons stashed. Ready for new capture or to load another image.");
        }


        function loadStashedSet() {
            const selectedIndex = stashedSetsDropdown.value;
            if (selectedIndex === "" || stashedPolygonSets.length === 0) {
                alert("Please select a stashed set to load.");
                return;
            }

            const setIndex = parseInt(selectedIndex, 10);
            if (isNaN(setIndex) || setIndex < 0 || setIndex >= stashedPolygonSets.length) {
                alert("Invalid stashed set selected.");
                return;
            }

            const selectedSet = stashedPolygonSets[setIndex];

            if (confirm(`This will replace your current polygons and view with "${selectedSet.name}". Continue?`)) {
                loaderOverlay.classList.remove('hidden');
                loaderOverlay.querySelector('p').textContent = 'Loading stashed set...';

                // polygons = []; // Old way
                initializeLayers(); // Reset current layers
                tempPoints = [];
                tempBox = null;
                currentManualPolygonPoints = [];
                // updatePolygonList(); // updateLayerPane will be called after layers are loaded

                fullImageShape = deepCopy(selectedSet.imageContext.fullImageShape);
                modelInputShape = deepCopy(selectedSet.imageContext.modelInputShape);
                geoTransformParams = deepCopy(selectedSet.imageContext.geoTransformParams);
                currentSnapshotGCPData = deepCopy(selectedSet.imageContext.gcpData); // Restore GCPs
                downloadGcpBtn.disabled = !(currentSnapshotGCPData && currentSnapshotGCPData.pixel_gcps && currentSnapshotGCPData.pixel_gcps.length > 0);


                const imageSrcToLoad = selectedSet.imageContext.imageSrc;
                const loadedSetSourceType = selectedSet.imageContext.sourceType;

                const finishLoadingPolygons = () => { // Renaming to finishLoadingLayers might be good, but data structure is the key
                    // polygons = deepCopy(selectedSet.data); // Old way
                    layers = deepCopy(selectedSet.data); // New: selectedSet.data now contains the layers array

                    // Re-initialize maskImage objects for each polygon within each layer
                    layers.forEach(layer => {
                        if (layer.polygons) {
                            layer.polygons.forEach(poly => {
                                if (poly.maskSrc) {
                                    let needsReload = true;
                                    if (poly.maskImage && poly.maskImage instanceof Image && poly.maskImage.complete && poly.maskImage.src === poly.maskSrc) {
                                        needsReload = false;
                                    }
                                    if (needsReload) {
                                        poly.maskImage = new Image();
                                        poly.maskImage.onload = () => {
                                            console.log(`Mask loaded for stashed polygon ${poly.id} in layer ${layer.name}`);
                                            draw(); 
                                        };
                                        poly.maskImage.onerror = () => {
                                            console.error(`Error loading mask for stashed polygon ${poly.id} in layer ${layer.name}`);
                                        };
                                        poly.maskImage.src = poly.maskSrc;
                                    }
                                }
                            });
                        }
                    });

                    updateLayerPane(); // Use new function name
                    resetTransform();
                    draw(); 
                    segmentControls.classList.remove('hidden');
                    // updateLayerPane(); // Called by finishLoadingPolygons after layers are set
                    loaderOverlay.classList.add('hidden');
                    alert(`"${selectedSet.name}" loaded.`);
                };

                if (imageSrcToLoad && imageSrcToLoad.startsWith('data:image/')) {
                    image = new Image();
                    image.onload = () => {
                        console.log("Stashed snapshot image loaded onto canvas.");
                        canvasContainer.classList.remove('hidden');
                        googleMapContainer.classList.add('hidden');
                        document.getElementById('canvas-placeholder').classList.add('hidden');

                        orthophotoConfigSection.classList.add('hidden');
                        satelliteConfigSection.classList.add('hidden');
                        snapshotControlsSection.classList.add('hidden');
                        imageSourceTypeSelect.value = '3dmap'; // Reflect that a snapshot is now the base

                        finishLoadingPolygons(); // This will call updateLayerPane
                    };
                    image.onerror = () => {
                        alert("Error loading stashed snapshot image.");
                        loaderOverlay.classList.add('hidden');
                        image = null;
                        fullImageShape = null; // Ensure reset on error
                        geoTransformParams = null;
                        updateLayerPane(); // Ensure buttons are disabled
                        draw();
                    };
                    image.src = imageSrcToLoad;
                } else { // Ortho/Satellite context OR Snapshot without image data (requires user to reload base)
                    image = null; // No displayable image loaded directly from stash
                    fullImageShape = selectedSet.imageContext.fullImageShape; // Still load the shape for potential future use if base reloaded
                    geoTransformParams = selectedSet.imageContext.geoTransformParams; // And transform

                    canvasContainer.classList.remove('hidden');
                    document.getElementById('canvas-placeholder').classList.remove('hidden'); // Show placeholder
                    googleMapContainer.classList.add('hidden');
                    segmentControls.classList.add('hidden'); // Hide segment controls as no image is active

                    if(loadedSetSourceType === 'orthophoto') {
                        imageSourceTypeSelect.value = 'orthophoto';
                        orthophotoConfigSection.classList.remove('hidden');
                        satelliteConfigSection.classList.add('hidden');
                        snapshotControlsSection.classList.add('hidden');
                    } else if(loadedSetSourceType === 'satellite') {
                        imageSourceTypeSelect.value = 'satellite';
                        orthophotoConfigSection.classList.add('hidden');
                        satelliteConfigSection.classList.remove('hidden');
                        snapshotControlsSection.classList.add('hidden');
                    } else if (loadedSetSourceType && loadedSetSourceType.startsWith('snapshot')) {
                        // This case means it was a snapshot context, but the image data wasn't stashed/retrieved.
                        imageSourceTypeSelect.value = '3dmap';
                        orthophotoConfigSection.classList.add('hidden');
                        satelliteConfigSection.classList.add('hidden');
                        snapshotControlsSection.classList.remove('hidden'); // Allow re-capture
                    } else { // Default if sourceType was unknown or not set
                         imageSourceTypeSelect.value = 'orthophoto'; // Default to ortho
                         orthophotoConfigSection.classList.remove('hidden');
                         satelliteConfigSection.classList.add('hidden');
                         snapshotControlsSection.classList.add('hidden');
                    }
                    alert(`Stashed set context ("${loadedSetSourceType || 'Unknown Type'}") loaded. Polygon data is available. Please load or capture the corresponding base image to enable full functionality.`);
                    finishLoadingPolygons(); // This will load polygon data and call updateLayerPane (which will disable zoom if image is null)
                }
            }
        }

        function deleteStashedSet() {
            const selectedIndex = stashedSetsDropdown.value;
            if (selectedIndex === "" || stashedPolygonSets.length === 0) {
                alert("Please select a stashed set to delete.");
                return;
            }

            const setIndex = parseInt(selectedIndex, 10);
            if (isNaN(setIndex) || setIndex < 0 || setIndex >= stashedPolygonSets.length) {
                alert("Invalid stashed set selected.");
                return;
            }

            const setToDelete = stashedPolygonSets[setIndex];
            if (confirm(`Are you sure you want to delete "${setToDelete.name}"?`)) {
                stashedPolygonSets.splice(setIndex, 1);
                updateStashedSetsDropdown(); // Refresh the dropdown
                alert(`"${setToDelete.name}" has been deleted.`);
            }
        }


        function updateStashedSetsDropdown() {
            stashedSetsDropdown.innerHTML = ''; // Clear existing options
            if (stashedPolygonSets.length === 0) {
                const option = document.createElement('option');
                option.value = "";
                option.textContent = "-- No stashed sets --";
                option.disabled = true;
                stashedSetsDropdown.appendChild(option);
                loadStashedBtn.disabled = true;
                deleteStashedBtn.disabled = true;
            } else {
                stashedPolygonSets.forEach((set, index) => {
                    const option = document.createElement('option');
                    option.value = index.toString();
                    let setType = "Unknown";
                    if (set.imageContext && set.imageContext.sourceType) {
                        if (set.imageContext.sourceType === 'snapshot_georef') setType = "Snapshot (Georef)";
                        else if (set.imageContext.sourceType === 'snapshot') setType = "Snapshot";
                        else if (set.imageContext.sourceType === 'orthophoto') setType = "Ortho";
                        else if (set.imageContext.sourceType === 'satellite') setType = "Satellite";
                    }
                    option.textContent = `${set.name} (${set.data.length} polys - ${setType})`;
                    stashedSetsDropdown.appendChild(option);
                });
                const hasSelection = stashedSetsDropdown.value !== "";
                loadStashedBtn.disabled = !hasSelection;
                deleteStashedBtn.disabled = !hasSelection;
            }
        }

        function initializeGoogleMap() {
            if (!window.googleMapsApiLoaded) {
                console.log("Google Maps API not ready yet (checked via flag).");
                mapInitialized = false; 
                return;
            }
            mapInitialized = true; 

            if (googleMap) { 
                return;
            }
            googleMap = new google.maps.Map(document.getElementById('google-map-container'), {
                center: { lat: 12.8797, lng: 121.7740 }, // Approximate center of the Philippines
                zoom: 5, // Zoom level to see most of the Philippines
                mapId: "DEMO_MAP_ID", 
                mapTypeId: 'satellite',
                tilt: 45, 
                streetViewControl: false,
                mapTypeControl: false,
                fullscreenControl: false,
            });
            console.log("Google Map Initialized");
        }

        function handleImageSourceTypeChange() {
            const selectedType = imageSourceTypeSelect.value;

            canvasContainer.classList.add('hidden');
            googleMapContainer.classList.add('hidden');
            document.getElementById('canvas-placeholder').classList.add('hidden');

            orthophotoConfigSection.classList.add('hidden');
            satelliteConfigSection.classList.add('hidden');
            snapshotControlsSection.classList.add('hidden');

            if (selectedType === 'orthophoto') {
                orthophotoConfigSection.classList.remove('hidden');
                canvasContainer.classList.remove('hidden');
                 if (!image) { 
                    document.getElementById('canvas-placeholder').classList.remove('hidden');
                }
            } else if (selectedType === 'satellite') {
                satelliteConfigSection.classList.remove('hidden');
                canvasContainer.classList.remove('hidden');
                 if (!image) { 
                    document.getElementById('canvas-placeholder').classList.remove('hidden');
                }
            } else if (selectedType === '3dmap') {
                snapshotControlsSection.classList.remove('hidden');
                googleMapContainer.classList.remove('hidden');
                initializeGoogleMap(); // This ensures map is ready

                // Sync Google Map data layer with current 'layers' state
                if (googleMap && googleMap.data) {
                    // Clear any existing features first
                    googleMap.data.forEach(feature => { googleMap.data.remove(feature); });
                    
                    // Re-add visible external layers from our state
                    layers.forEach(layer => {
                        if (layer.visible && layer.type === 'external' && layer.mapDataGeoJson) {
                            try {
                                googleMap.data.addGeoJson(layer.mapDataGeoJson);
                            } catch (e) {
                                console.error("Error adding GeoJSON to map data layer for layer:", layer.name, e);
                                // Optionally alert user or handle more gracefully
                            }
                        }
                    });
                    // Re-apply a general style
                    googleMap.data.setStyle(feature => {
                        const color = feature.getProperty('color') || 'rgba(0, 0, 255, 1)';
                        let fillOpacity = 0.3;
                        let finalFillColor = `rgba(0,0,255,${fillOpacity})`;
                        try {
                            const colorParts = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([0-9.]+))?\)/);
                            if (colorParts) {
                                finalFillColor = `rgba(${colorParts[1]}, ${colorParts[2]}, ${colorParts[3]}, ${fillOpacity})`;
                            }
                        } catch(e) { /* use default if color parsing fails */ }
                        return { 
                            fillColor: finalFillColor, 
                            strokeColor: feature.getProperty('color') || 'rgba(0,0,150,1)', 
                            strokeWeight: 1, 
                            clickable: false 
                        };
                    });
                    console.log("Synchronized Google Map data layer with current layer state.");
                }
                segmentControls.classList.add('hidden'); 
            }
        }

        async function captureAndDisplaySnapshot() {
            if (!googleMap || !mapInitialized) {
                alert("3D Map is not initialized yet.");
                return;
            }

            if (isGcpPlacementMode && gcpPoints.length < 4) {
                alert("Please place all 4 GCPs before capturing, or exit GCP placement mode.");
                return;
            }

            loaderOverlay.classList.remove('hidden');
            loaderOverlay.querySelector('p').textContent = 'Capturing 3D map view...';

            try {
                // Calculate pixel coordinates for GCPs BEFORE taking the snapshot
                const pixelGcps = [];
                if (isGcpPlacementMode && gcpPoints.length === 4) {
                    const mapProjection = googleMap.getProjection();
                    const mapBounds = googleMap.getBounds();
                    if (!mapProjection || !mapBounds) {
                        throw new Error("Map projection or bounds not available for GCP conversion.");
                    }
                    const topRight = mapProjection.fromLatLngToPoint(mapBounds.getNorthEast());
                    const bottomLeft = mapProjection.fromLatLngToPoint(mapBounds.getSouthWest());
                    const scale = Math.pow(2, googleMap.getZoom());
                    
                    const mapDiv = googleMap.getDiv();
                    const mapRect = mapDiv.getBoundingClientRect();

                    for (const gcp of gcpPoints) {
                        const worldPoint = mapProjection.fromLatLngToPoint(gcp.geo);
                        const pixelX = (worldPoint.x - bottomLeft.x) * scale;
                        const pixelY = (worldPoint.y - topRight.y) * scale;
                        pixelGcps.push([pixelX, pixelY]);
                    }
                }

                const capturedCanvas = await html2canvas(googleMapContainer, { useCORS: true, allowTaint: true });
                const snapshotDataUrl = capturedCanvas.toDataURL('image/jpeg', 0.9);

                googleMapContainer.classList.add('hidden');
                canvasContainer.classList.remove('hidden');
                document.getElementById('canvas-placeholder').classList.add('hidden');

                image = new Image(); 
                image.onload = () => {
                    // Instead of initializeLayers(), only clear segmentation layer polygons
                    const segLayer = layers.find(l => l.id === defaultSegmentationLayerId);
                    if (segLayer) {
                        segLayer.polygons = []; 
                        console.log("Cleared polygons from Segmentation Output layer for new snapshot.");
                    }
                    // Clear temporary SAM prompts for the new canvas context
                    tempPoints = [];
                    tempBox = null;
                    currentManualPolygonPoints = [];

                    // If coming from a live map view, clear its data as snapshot now holds visuals
                    if (googleMap && googleMap.data && imageSourceTypeSelect.value === '3dmap') { // Check if 3dmap was the source
                         googleMap.data.forEach(feature => { googleMap.data.remove(feature); });
                         console.log("Cleared Google Map data layer as snapshot is now active base.");
                    }
                    
                    updateLayerPane(); // Update pane (external layers should still be listed)
                    resetTransform(); 
                    draw(); // Draw snapshot and any persistent vector layers on canvas
                    segmentControls.classList.remove('hidden'); 
                    updateCursorBasedOnMode();
                    console.log("Snapshot captured and displayed locally. Sending to backend...");

                    const geoGcps = isGcpPlacementMode ? gcpPoints.map(gcp => [gcp.geo.lng(), gcp.geo.lat()]) : null;
                    sendSnapshotToBackend(snapshotDataUrl, pixelGcps, geoGcps);
                };
                image.onerror = () => {
                    alert("Failed to load snapshot image onto canvas for display.");
                    googleMapContainer.classList.remove('hidden');
                    canvasContainer.classList.add('hidden');
                    segmentControls.classList.add('hidden');
                };
                image.src = snapshotDataUrl;
            } catch (error) {
                console.error("Error capturing snapshot:", error);
                alert(`Failed to capture snapshot: ${error.message}`);
                googleMapContainer.classList.remove('hidden');
                canvasContainer.classList.add('hidden');
                segmentControls.classList.add('hidden');
            } finally {
                loaderOverlay.classList.add('hidden');
            }
        }

        async function sendSnapshotToBackend(snapshotDataUrl, pixelGcps, geoGcps) {
            loaderOverlay.classList.remove('hidden'); 
            loaderOverlay.querySelector('p').textContent = 'Backend is preparing snapshot...';

            const payload = {
                snapshot_image: snapshotDataUrl,
                resolution: 'original'
            };

            if (pixelGcps && pixelGcps.length === 4 && geoGcps && geoGcps.length === 4) {
                payload.pixel_gcps = pixelGcps;
                payload.geo_gcps = geoGcps;
                console.log("Sending snapshot with GCPs:", { pixel_gcps: pixelGcps, geo_gcps: geoGcps });
            }

            try {
                const response = await fetch(`${BACKEND_URL}/set_image_from_snapshot`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload),
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || `Failed with status ${response.status}`);

                geoTransformParams = data.geo_transform_params; 
                fullImageShape = data.full_image_shape;     
                modelInputShape = data.model_input_shape;   
                
                // Store GCPs if they were used for this snapshot
                if (data.image_source_type === 'snapshot_georef') {
                    currentSnapshotGCPData = {
                        pixel_gcps: pixelGcps,
                        geo_gcps: geoGcps
                    };
                    downloadGcpBtn.disabled = false;
                } else {
                    currentSnapshotGCPData = null;
                    downloadGcpBtn.disabled = true;
                }

                console.log("Backend processed snapshot. Full shape:", fullImageShape, "Model input shape:", modelInputShape);
                alert("Snapshot ready for segmentation on the backend.");
                updateLayerPane(); // Update layer pane to reflect new image state (enable zoom buttons)

            } catch (error) {
                alert(`Failed to send snapshot to backend. Error: ${error.message}`);
                googleMapContainer.classList.remove('hidden'); 
                canvasContainer.classList.add('hidden');    
                segmentControls.classList.add('hidden'); 
                snapshotControlsSection.classList.remove('hidden'); 
                image = null;
                fullImageShape = null; // Ensure these are nulled on error
                geoTransformParams = null;
                updateLayerPane(); // Keep buttons disabled
            } finally {
                loaderOverlay.classList.add('hidden');
            }
        }

        async function loadEarthEngineImage() {
            const imageId = eeImageIdInput.value;
            const minLon = parseFloat(eeMinLonInput.value);
            const minLat = parseFloat(eeMinLatInput.value);
            const maxLon = parseFloat(eeMaxLonInput.value);
            const maxLat = parseFloat(eeMaxLatInput.value);
            const bands = eeBandsInput.value || "B4,B3,B2"; 
            const dateStart = eeDateStartInput.value;
            const dateEnd = eeDateEndInput.value;
            const selectedResolution = eeResolutionSelect.value;
            const visMin = eeVisMinInput.value; 
            const visMax = eeVisMaxInput.value; 


            if (!imageId) {
                alert("Please provide an Earth Engine Image ID.");
                return;
            }
            if (isNaN(minLon) || isNaN(minLat) || isNaN(maxLon) || isNaN(maxLat)) {
                alert("Please provide valid numeric values for ROI (bounding box).");
                return;
            }
            if (minLon >= maxLon || minLat >= maxLat) {
                alert("Min longitude/latitude must be less than Max longitude/latitude.");
                return;
            }

            if (isEditMode) exitEditMode(false); 

            loaderOverlay.classList.remove('hidden');
            loaderOverlay.querySelector('p').textContent = 'Fetching & preparing EE image...';

            const payload = {
                ee_image_id: imageId,
                roi: { min_lon: minLon, min_lat: minLat, max_lon: maxLon, max_lat: maxLat },
                bands: bands,
                resolution: selectedResolution
            };

            if (dateStart && dateEnd) {
                payload.date_range = { start: dateStart, end: dateEnd };
            } else if (dateStart || dateEnd) { 
                alert("Please provide both Start and End Date for a date range, or leave both empty.");
                loaderOverlay.classList.add('hidden');
                return;
            }

            if (visMin !== "") {
                const numVisMin = parseFloat(visMin);
                if (!isNaN(numVisMin)) {
                    payload.vis_min = numVisMin;
                } else {
                    alert("Invalid 'Vis Min' value. Please enter a number or leave it empty.");
                    loaderOverlay.classList.add('hidden');
                    return;
                }
            }
            if (visMax !== "") {
                const numVisMax = parseFloat(visMax);
                if (!isNaN(numVisMax)) {
                    payload.vis_max = numVisMax;
                } else {
                    alert("Invalid 'Vis Max' value. Please enter a number or leave it empty.");
                    loaderOverlay.classList.add('hidden');
                    return;
                }
            }

            if (payload.hasOwnProperty('vis_min') && payload.hasOwnProperty('vis_max')) {
                if (payload.vis_min >= payload.vis_max) {
                    alert("'Vis Min' must be less than 'Vis Max'.");
                    loaderOverlay.classList.add('hidden');
                    return;
                }
            }


            try {
                const response = await fetch(`${BACKEND_URL}/set_image_from_ee`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload),
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || `Failed with status ${response.status}`);

                geoTransformParams = data.geo_transform_params;
                fullImageShape = data.full_image_shape;
                modelInputShape = data.model_input_shape;
                console.log("Received from EE backend: fullImageShape:", fullImageShape, "modelInputShape:", modelInputShape);

                image = new Image();
                image.onload = () => {
                    document.getElementById('canvas-placeholder').classList.add('hidden');
                    zoomControlsContainer.classList.remove('hidden');
                    resetTransform();
                    draw();
                    segmentControls.classList.remove('hidden');
                    updateCursorBasedOnMode();
                    updateLayerPane(); // Enable zoom buttons now that image is loaded
                };
                image.src = data.preview_image;
                imagePathInput.value = ''; // Clear input fields from other modes
                worldfilePathInput.value = '';

            } catch (error) {
                alert(`Failed to load Earth Engine image. Error: ${error.message}`);
                image = null; // Ensure image is null on error
                fullImageShape = null;
                updateLayerPane(); // Keep buttons disabled
            } finally {
                loaderOverlay.classList.add('hidden');
            }
        }

        function handleTabNavigation(e) {
            if (e.key === 'Tab') {
                e.preventDefault(); 

                const modes = ['point', 'box', 'draw_polygon'];
                const currentModeRadio = document.querySelector('input[name="segment-mode"]:checked');
                let currentIndex = modes.indexOf(currentModeRadio.value);

                currentIndex = (currentIndex + 1) % modes.length; 

                const nextModeRadio = document.querySelector(`input[name="segment-mode"][value="${modes[currentIndex]}"]`);
                if (nextModeRadio) {
                    nextModeRadio.checked = true;
                    const event = new Event('change', { bubbles: true });
                    nextModeRadio.dispatchEvent(event);
                }
            }
        }

        function toggleLeftSidebar() {
            isLeftSidebarCollapsed = !isLeftSidebarCollapsed;
            if (isLeftSidebarCollapsed) {
                leftSidebar.classList.remove('md:w-80');
                leftSidebar.classList.add('md:w-16'); 
                leftSidebarContent.classList.add('hidden');
                leftSidebarTitle.classList.add('hidden');
                leftSidebarIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>'; 
            } else {
                leftSidebar.classList.remove('md:w-16');
                leftSidebar.classList.add('md:w-80');
                leftSidebarContent.classList.remove('hidden');
                leftSidebarTitle.classList.remove('hidden');
                leftSidebarIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>'; 
            }
            window.dispatchEvent(new Event('resize'));
        }

        function toggleRightSidebar() {
            isRightSidebarCollapsed = !isRightSidebarCollapsed;
            if (isRightSidebarCollapsed) {
                rightSidebar.classList.remove('md:w-80');
                rightSidebar.classList.add('md:w-16'); 
                rightSidebarContent.classList.add('hidden');
                const downloadBtnContainer = downloadBtn.parentElement;
                if (downloadBtnContainer) {
                    downloadBtnContainer.classList.add('hidden');
                }
                rightSidebarTitle.classList.add('hidden');
                rightSidebarIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>'; 
            } else {
                rightSidebar.classList.remove('md:w-16');
                rightSidebar.classList.add('md:w-80');
                rightSidebarContent.classList.remove('hidden');
                const downloadBtnContainer = downloadBtn.parentElement;
                if (downloadBtnContainer) {
                    downloadBtnContainer.classList.remove('hidden');
                }
                rightSidebarTitle.classList.remove('hidden');
                rightSidebarIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>'; 
            }
            window.dispatchEvent(new Event('resize'));
        }

        function updateCopyrightYear() {
            if (currentYearSpan) {
                currentYearSpan.textContent = new Date().getFullYear();
            }
        }

        function applyTheme(theme) {
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        }

        function handleThemeChange() {
            const selectedTheme = themeSelect.value;
            localStorage.setItem('theme', selectedTheme);

            if (selectedTheme === 'system') {
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    applyTheme('dark');
                } else {
                    applyTheme('light');
                }
            } else {
                applyTheme(selectedTheme);
            }
        }

        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'system';
            themeSelect.value = savedTheme;

            if (savedTheme === 'system') {
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    applyTheme('dark');
                } else {
                    applyTheme('light');
                }
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                    if (themeSelect.value === 'system') { 
                        applyTheme(e.matches ? 'dark' : 'light');
                    }
                });
            } else {
                applyTheme(savedTheme);
            }
        }


        async function checkBackendStatus() {
            try {
                const response = await fetch(BACKEND_URL);
                const data = await response.json();

                if (response.ok) {
                    if (statusDot.classList.contains('red')) {
                        statusDot.classList.replace('red','green');
                        statusText.textContent = `Backend: Connected (${data.current_device.toUpperCase()})`;
                    } else {
                        statusText.textContent = `Backend: Connected (${data.current_device.toUpperCase()})`;
                    }
                    currentBackendDevice = data.current_device;
                    if (deviceSelect.value !== currentBackendDevice) {
                        deviceSelect.value = currentBackendDevice;
                    }

                    if (data.available_resolutions &&
                        (availableResolutions.length !== data.available_resolutions.length ||
                         !availableResolutions.every((val, idx) => val === data.available_resolutions[idx]))) {
                        availableResolutions = data.available_resolutions;
                        populateResolutionDropdown(availableResolutions);
                    }

                } else {
                    throw new Error(data.message || "Backend not responding as expected");
                }
            } catch (error) {
                if (statusDot.classList.contains('green')) {
                    statusDot.classList.replace('green','red');
                }
                statusText.textContent = 'Backend: Disconnected';
                currentBackendDevice = '';
            }
        }

        function populateResolutionDropdown(resolutions) {
            const currentVal = resolutionSelect.value;
            resolutionSelect.innerHTML = ''; 
            resolutions.forEach(resKey => {
                const option = document.createElement('option');
                option.value = resKey;
                option.textContent = resKey.charAt(0).toUpperCase() + resKey.slice(1);
                resolutionSelect.appendChild(option);
            });
            if (resolutions.includes(currentVal)) {
                resolutionSelect.value = currentVal;
            } else if (resolutions.includes('original')) {
                resolutionSelect.value = 'original';
            }
        }

        async function handleDeviceChange() {
            const selectedDevice = deviceSelect.value;
            if (selectedDevice === currentBackendDevice) return;

            loaderOverlay.classList.remove('hidden');
            loaderOverlay.querySelector('p').textContent = `Switching to ${selectedDevice.toUpperCase()}...`;

            try {
                const response = await fetch(`${BACKEND_URL}/set_device`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ device_preference: selectedDevice })
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || "Failed to switch device");

                alert(data.message); 
                currentBackendDevice = selectedDevice; 
                statusText.textContent = `Backend: Connected (${currentBackendDevice.toUpperCase()})`;

            } catch (error) {
                alert(`Error switching device: ${error.message}`);
                deviceSelect.value = currentBackendDevice;
            } finally {
                loaderOverlay.classList.add('hidden');
            }
        }
        
        async function processFiles() {
            const imagePath = imagePathInput.value;
            const worldFilePath = worldfilePathInput.value;
            const selectedResolution = resolutionSelect.value;

            if (!imagePath || !worldFilePath) {
                alert("Please provide full paths for both the image and the world file.");
                return;
            }
            if (isEditMode) exitEditMode(false); 

            loaderOverlay.classList.remove('hidden');
            loaderOverlay.querySelector('p').textContent = 'Backend is preparing image...';
            try {
                const response = await fetch(`${BACKEND_URL}/set_image_from_path`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        image_path: imagePath,
                        world_file_path: worldFilePath,
                        resolution: selectedResolution
                    }),
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error);
                
                geoTransformParams = data.geo_transform_params;
                fullImageShape = data.full_image_shape; 
                modelInputShape = data.model_input_shape; 
                console.log("Received fullImageShape:", fullImageShape, "modelInputShape:", modelInputShape);

                image = new Image();
                image.onload = () => {
                    document.getElementById('canvas-placeholder').classList.add('hidden');
                    zoomControlsContainer.classList.remove('hidden'); 
                    resetTransform();
                    draw();
                    segmentControls.classList.remove('hidden');
                    canvasContainer.classList.add('segmenting-point'); // Default cursor for point mode after load
                    updateLayerPane(); // Enable zoom buttons now that image is loaded
                };
                image.src = data.preview_image;
            } catch (error) {
                alert(`Failed to process files. Error: ${error.message}`);
                image = null; // Ensure image is null on error
                fullImageShape = null;
                updateLayerPane(); // Keep buttons disabled
            } finally {
                loaderOverlay.classList.add('hidden');
            }
        }

        function handleMouseDown(e) {
            if (e.button !== 0) return; 

            const { x: canvasX, y: canvasY } = getMousePosOnCanvas(e);

            if (image && segmentMode === 'draw_polygon' && e.button === 0 && (e.ctrlKey || e.metaKey) && currentManualPolygonPoints.length > 0) {
                currentManualPolygonPoints.pop();
                draw();
                return;
            }

            if (image && ( (isCtrlPressed && e.button === 0) || (e.button === 1) ) ) {
                isPanning = true;
                panStart = { x: e.clientX - transform.x, y: e.clientY - transform.y };
                canvasContainer.style.cursor = 'grabbing';
                canvasContainer.classList.add('panning');
                isDrawingBox = false; 
                if (segmentMode === 'draw_polygon') { /* No points added if panning */ }
                return;
            }

            if (isEditMode && selectedPolygonForEdit) {
                const pixelPolygon = selectedPolygonForEdit.points.map(p => geoToPixel(p, selectedPolygonForEdit.isGeographic));
                const vertexRadius = 6 / transform.scale;
                const clickXOnPreview = (canvasX - transform.x) / transform.scale;
                const clickYOnPreview = (canvasY - transform.y) / transform.scale;

                for (let i = 0; i < pixelPolygon.length; i++) {
                    const vertex = pixelPolygon[i];
                    const dist = Math.sqrt(Math.pow(vertex.x - clickXOnPreview, 2) + Math.pow(vertex.y - clickYOnPreview, 2));

                    if (dist < vertexRadius) {
                        if (e.ctrlKey || e.metaKey) { 
                            if (selectedPolygonForEdit.points.length > 3) {
                                selectedPolygonForEdit.points.splice(i, 1);
                                draw();
                                draggedVertexIndex = null;
                                console.log(`Deleted vertex ${i} from polygon ${selectedPolygonForEdit.id}`);
                                e.preventDefault();
                                return;
                            } else {
                                alert("A polygon must have at least 3 vertices.");
                                return;
                            }
                        } else {
                            draggedVertexIndex = i;
                            canvasContainer.style.cursor = 'grabbing'; 
                            isDrawingBox = false; 
                            return;
                        }
                    }
                }

            } else { 
                if (segmentMode === 'box' && e.button === 0) {
                    isDrawingBox = true;
                    tempBox = { x1: canvasX, y1: canvasY, x2: canvasX, y2: canvasY };
                } else if (segmentMode === 'draw_polygon' && e.button === 0) { 
                    currentManualPolygonPoints.push({ x: canvasX, y: canvasY });
                    draw();
                }
            }
        }

        function handleMouseMove(e) {
            currentMousePos = getMousePosOnCanvas(e); 

            if (isPanning) { 
                transform.x = e.clientX - panStart.x;
                transform.y = e.clientY - panStart.y;
                draw();
                return; 
            }

            if (isEditMode && draggedVertexIndex !== null && selectedPolygonForEdit) { 
                const newPoint = pixelToGeo(currentMousePos.x, currentMousePos.y); // Returns pixel or geo based on its internal logic
                if (newPoint) {
                    if (selectedPolygonForEdit.isGcpDerived && selectedPolygonForEdit.pixelPoints) {
                        selectedPolygonForEdit.pixelPoints[draggedVertexIndex] = newPoint; // Store as pixel
                    } else {
                        selectedPolygonForEdit.points[draggedVertexIndex] = newPoint; // Store as geo (or pixel if not isGeographic)
                    }
                    draw();
                }
            } else if (isEditMode && selectedPolygonForEdit && isShiftPressed && draggedVertexIndex === null) { 
                const { x: canvasX, y: canvasY } = getMousePosOnCanvas(e);
                const previewMouseX = (canvasX - transform.x) / transform.scale;
                const previewMouseY = (canvasY - transform.y) / transform.scale;

                let onEdge = false;
                if (selectedPolygonForEdit) {
                    const pixelPolygon = selectedPolygonForEdit.points.map(p => geoToPixel(p, selectedPolygonForEdit.isGeographic)); 
                    if (pixelPolygon.length >= 2) {
                        const closestEdgeInfo = findClosestEdgeIndexForHover(pixelPolygon, { x: previewMouseX, y: previewMouseY });
                        if (closestEdgeInfo.minDistSq < (10 / transform.scale) * (10 / transform.scale)) { 
                            onEdge = true;
                        }
                    }
                }
                canvasContainer.style.cursor = onEdge ? 'cell' : 'default'; 
            } else if (isDrawingBox && !isEditMode) { 
                tempBox.x2 = currentMousePos.x;
                tempBox.y2 = currentMousePos.y;
                draw();
            } else if (segmentMode === 'draw_polygon' && currentManualPolygonPoints.length > 0 && !isEditMode) { 
                draw(); 
            } else {
                if(!isPanning && !isCtrlPressed) updateCursorBasedOnMode();
            }
        }


        function handleMouseUp(e) {
           
            const wasPanning = isPanning; // Keep track if a pan just ended
            const { x: canvasX, y: canvasY } = getMousePosOnCanvas(e); 

            if (isPanning) {
                isPanning = false;
                if (!isCtrlPressed) { 
                    updateCursorBasedOnMode(); 
                    canvasContainer.classList.remove('panning');
                }
            }

            if (wasPanning) { // If a pan just ended, don't process other click actions
                return;
            }

            // --- Edit Mode MouseUp Logic ---
            if (isEditMode) {
                if (draggedVertexIndex !== null) { // Finished dragging a vertex
                    draggedVertexIndex = null;
                    // Cursor update will be handled by mousemove or keyup if shift/ctrl were involved
                    if (!isCtrlPressed && !isShiftPressed) { 
                         updateCursorBasedOnMode();
                    }
                } else if (isShiftPressed && selectedPolygonForEdit && e.button === 0) { // Add vertex on shift+click
                    const newPointForVertex = pixelToGeo(canvasX, canvasY); // pixelToGeo handles coord system
                    if (newPointForVertex) {
                        if (selectedPolygonForEdit.isGcpDerived && selectedPolygonForEdit.pixelPoints) {
                            addVertexToPolygon(selectedPolygonForEdit, newPointForVertex, true); // true for pixelPoints
                        } else {
                            addVertexToPolygon(selectedPolygonForEdit, newPointForVertex, false); // false for .points
                        }
                        draw();
                    }
                }
                return; // Consume click if in edit mode
            }

            // --- Select Mode Logic ---
            if (segmentMode === 'select' && e.button === 0) { 
                const previewX = (canvasX - transform.x) / transform.scale;
                const previewY = (canvasY - transform.y) / transform.scale;
                let clickedOnAPolygon = false;

                layerLoop: // Label for breaking out of nested loops
                for (const layer of layers) {
                    if (!layer.visible || !layer.polygons) continue;
                    for (const poly of layer.polygons) {
                        let polyVerticesInPreviewCoords;
                        if (poly.isGcpDerived && poly.pixelPoints) {
                            polyVerticesInPreviewCoords = poly.pixelPoints.map(p => geoToPixel(p, false));
                        } else {
                            polyVerticesInPreviewCoords = poly.points.map(p => geoToPixel(p, poly.isGeographic));
                        }

                        if (polyVerticesInPreviewCoords && polyVerticesInPreviewCoords.length >= 3) {
                            if (isPointInPolygon([previewX, previewY], polyVerticesInPreviewCoords.map(p_ => [p_.x, p_.y]))) {
                                if (selectedPolygonIdForInspection === poly.id) {
                                    // Clicked on already selected polygon - do nothing or toggle off if desired
                                } else {
                                    selectedPolygonIdForInspection = poly.id;
                                    console.log(`Polygon ${poly.id} from layer '${layer.name}' selected for inspection.`);
                                }
                                clickedOnAPolygon = true;
                                break layerLoop; // Found the topmost polygon clicked
                            }
                        }
                    }
                }

                if (!clickedOnAPolygon && selectedPolygonIdForInspection !== null) {
                    selectedPolygonIdForInspection = null;
                    console.log("Selection cleared (clicked background).");
                }
                draw();
                updateLayerPane(); // Update list highlighting
                return;
            }
            
            // --- Other modes MouseUp Logic (Box, Point, Draw Polygon) ---
            if (isDrawingBox) { 
                isDrawingBox = false;
                // Potentially run segmentation for box mode if desired on mouse up, or rely on button
                draw(); 
                if (!isCtrlPressed && !isEditMode) updateCursorBasedOnMode(); // Reset cursor if not panning
                return; 
            }

            if (segmentMode === 'point' && image && e.button !== 1) { // Allow left or right click for points
                const {x, y} = getMousePosOnCanvas(e); // These are canvas coords
                if (e.button === 0) { // Left click - positive prompt
                    tempPoints.push({ x, y, label: 1 });
                    runSegmentation();
                } else if (e.button === 2) { 
                    tempPoints.push({ x, y, label: 0 });
                    runSegmentation();
                }
                draw();
            } else if (segmentMode === 'draw_polygon' && e.button === 2 && currentManualPolygonPoints.length >= 3) { 
                const geoPoints = currentManualPolygonPoints.map(p => {
                    const previewX = (p.x - transform.x) / transform.scale;
                    const previewY = (p.y - transform.y) / transform.scale;
                    return previewPixelToGeo(previewX, previewY); 
                }).filter(p => p !== null); 

                if (geoPoints.length >= 3) {
                    const color = `rgba(${Math.floor(Math.random()*155)+100}, ${Math.floor(Math.random()*155)+100}, ${Math.floor(Math.random()*155)+100}, 1)`;
                    const newPoly = {
                        id: nextPolygonId++,
                        points: geoPoints, 
                        color: color,
                        isGeographic: imageSourceTypeSelect.value !== '3dmap' || (currentSnapshotGCPData && currentSnapshotGCPData.pixel_gcps.length > 0), 
                        Farmer_Name: "", Farm_Address: "", Registered_Area: 0, Tobacco_Type: "",
                        Sub_type: "", Variety: "", Validated_Area: 0, Difference: 0
                    };
                    
                    const segLayer = layers.find(l => l.id === defaultSegmentationLayerId);
                    if (segLayer) {
                        segLayer.polygons.push(newPoly);
                    } else {
                        console.error("Default segmentation layer not found. Adding drawn polygon to a new layer.");
                        layers.push({ id: 'temp_drawn_layer_' + nextPolygonId++, name: 'Orphaned Drawn Polygons', polygons: [newPoly], visible: true, opacity: 1.0, deletable: true, type: 'segmentation' });
                    }
                    updateLayerPane(); // Will be renamed from updatePolygonList
                } else {
                    alert("Failed to convert enough points for a valid polygon. Ensure the image is loaded.");
                }
                currentManualPolygonPoints = [];
                draw();
            } else if (segmentMode === 'draw_polygon' && e.button === 2 && currentManualPolygonPoints.length > 0 && currentManualPolygonPoints.length < 3) {
                alert("A polygon needs at least 3 points. Right-click again to cancel or add more points. (Or press Esc to cancel)");
            } else if (segmentMode === 'draw_polygon' && e.button === 2 && currentManualPolygonPoints.length === 0) {
                // Do nothing, just a right click in draw mode with no points
            }
        }

        async function runSegmentation() {
            if (isEditMode) exitEditMode(true); 
            if (segmentMode === 'draw_polygon') return; 

            if (!tempPoints.length && !tempBox) {
                if (segmentMode !== 'point' || (event && event.target.id === 'segment-btn')) {
                    alert("Please add a point or draw a box.");
                }
                return;
            }

            loaderOverlay.classList.remove('hidden');
            loaderOverlay.querySelector('p').textContent = 'SAM is processing...';
            
            let payload = {
                points: [],
                box: null
            };

            if (segmentMode === 'point' && tempPoints.length > 0) {
                payload.points = tempPoints.map(p => ({
                    x: (p.x - transform.x) / transform.scale,
                    y: (p.y - transform.y) / transform.scale,
                    label: p.label
                }));
                payload.box = null; 
                console.log("Frontend: Preparing POINT payload for /predict");
            } else if (segmentMode === 'box' && tempBox) {
                const normalizedX1 = Math.min(tempBox.x1, tempBox.x2);
                const normalizedY1 = Math.min(tempBox.y1, tempBox.y2);
                const normalizedX2 = Math.max(tempBox.x1, tempBox.x2);
                const normalizedY2 = Math.max(tempBox.y1, tempBox.y2);

                payload.box = {
                    x1: (normalizedX1 - transform.x) / transform.scale,
                    y1: (normalizedY1 - transform.y) / transform.scale,
                    x2: (normalizedX2 - transform.x) / transform.scale,
                    y2: (normalizedY2 - transform.y) / transform.scale
                };
                payload.points = []; 
                console.log("Frontend: Preparing BOX payload for /predict");
            } else {
                console.log("Frontend: No valid prompts to send for segmentation in current mode.");
                loaderOverlay.classList.add('hidden');
                return;
            }

            console.log("Frontend: Sending payload to /predict:", JSON.stringify(payload, null, 2)); 

            try {
                const response = await fetch(`${BACKEND_URL}/predict`, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || "Prediction failed");
                
                if (data.polygon && data.polygon.length > 2) {
                    const color = `rgba(${Math.floor(Math.random()*155)+100}, ${Math.floor(Math.random()*155)+100}, ${Math.floor(Math.random()*155)+100}, 1)`;
                    
                    // Determine if the current context is a GCP-enabled snapshot
                    const isSnapshotContext = (imageSourceTypeSelect.value === '3dmap' || (image && image.src.startsWith('data:image/')));
                    const hasValidGCPData = currentSnapshotGCPData && 
                                            currentSnapshotGCPData.pixel_gcps && currentSnapshotGCPData.pixel_gcps.length >= 4 &&
                                            currentSnapshotGCPData.geo_gcps && currentSnapshotGCPData.geo_gcps.length >= 4;
                    const isGcpContext = isSnapshotContext && hasValidGCPData;

                    const newPolygon = {
                        id: nextPolygonId++,
                        points: data.polygon, // Geographic points if transform succeeded, otherwise pixel points
                        pixelPoints: (isGcpContext && data.pixel_polygon_full_res && data.polygon_type === 'geographic') ? data.pixel_polygon_full_res : null,
                        color: color,
                        isGeographic: data.polygon_type === 'geographic',
                        isGcpDerived: isGcpContext && data.polygon_type === 'geographic' && data.pixel_polygon_full_res,
                        maskSrc: data.mask_image, 
                        maskImage: null,
                        Farmer_Name: "", Farm_Address: "", Registered_Area: 0, Tobacco_Type: "",
                        Sub_type: "", Variety: "", Validated_Area: 0, Difference: 0
                    };
                    
                    if (newPolygon.isGcpDerived) {
                        console.log("Created GCP-derived polygon:", newPolygon.id, "with pixelPoints length:", newPolygon.pixelPoints ? newPolygon.pixelPoints.length : 'null');
                    }

                    if (newPolygon.maskSrc) {
                        newPolygon.maskImage = new Image();
                        newPolygon.maskImage.onload = () => {
                            draw(); // Redraw once the mask image is loaded
                        };
                        newPolygon.maskImage.src = newPolygon.maskSrc;
                    }

                        // Add to the default segmentation layer
                        const segLayer = layers.find(l => l.id === defaultSegmentationLayerId);
                        if (segLayer) {
                            segLayer.polygons.push(newPolygon);
                        } else {
                            // Fallback if default layer somehow not found (should not happen)
                            console.error("Default segmentation layer not found. Adding polygon to a new layer.");
                            layers.push({ id: 'temp_seg_layer_' + nextPolygonId++, name: 'Orphaned Segments', polygons: [newPolygon], visible: true, opacity: 1.0, deletable: true, type: 'segmentation' });
                        }
                        
                        updateLayerPane(); // Will be renamed from updatePolygonList
                    draw();

                    if (segmentMode === 'point') {
                        tempPoints = [];
                        console.log("Cleared tempPoints after successful point segmentation.");
                    }
                } else {
                    if (segmentMode !== 'point' || (event && event.target.id === 'segment-btn')) {
                        alert("Segmentation did not return a valid polygon.");
                    }
                }
            } catch (error) {
                alert(`Error during segmentation: ${error.message}`);
            } finally {
                loaderOverlay.classList.add('hidden');
            }
        }

        function clearPrompts() {
            if (isEditMode) exitEditMode(true); 
            tempPoints = [];
            tempBox = null;
            currentManualPolygonPoints = []; 
            draw();
        }
        
        function draw() {
            if (!image) return;
            const rect = canvasContainer.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.translate(transform.x, transform.y);
            ctx.scale(transform.scale, transform.scale);
            ctx.drawImage(image, 0, 0);

            // Iterate through layers for drawing
            // Drawing order: first layer in array is drawn first (bottom), last layer is drawn last (top)
            layers.forEach(layer => {
                // --- BEGIN HIGH-LEVEL DIAGNOSTIC LOG ---
                console.log(`[Draw Loop Start] Layer: ${layer.name}, Symbology Type: ${layer.symbology ? layer.symbology.type : 'undefined'}, Visible: ${layer.visible}, Polygon Count: ${layer.polygons ? layer.polygons.length : 0}`);
                // --- END HIGH-LEVEL DIAGNOSTIC LOG ---

                if (!layer.visible || !layer.polygons) return; 

                const originalAlpha = ctx.globalAlpha; // Save current globalAlpha
                ctx.globalAlpha = layer.opacity; // Apply layer's opacity

                layer.polygons.forEach(poly => {
                    const isEditingThisPoly = isEditMode && selectedPolygonForEdit && selectedPolygonForEdit.id === poly.id;
                    const isInspectedThisPoly = selectedPolygonIdForInspection === poly.id;

                    if (layer.type === 'external' || poly.isExternal) { // Debug for external layers/polygons
                        console.log("Drawing external polygon:", poly.id, "from layer:", layer.name);
                        console.log("Original points (poly.points):", JSON.stringify(poly.points));
                    }

                    let pointsForConversion = poly.points;
                    let useGeoFlagForConversion = poly.isGeographic;

                    if (poly.isGcpDerived && poly.pixelPoints && poly.pixelPoints.length >= 3) {
                        pointsForConversion = poly.pixelPoints;
                        useGeoFlagForConversion = false;
                    } else if (poly.isGcpDerived && (!poly.pixelPoints || poly.pixelPoints.length < 3)) {
                        console.warn(`GCP-derived polygon ${poly.id} in layer ${layer.name} is missing valid pixelPoints. Attempting to draw with geo points.`);
                    }
                    
                    // Map points and filter out any nulls that might result from geoToPixel failing
                    const pixelPolygon = pointsForConversion.map(p => geoToPixel(p, useGeoFlagForConversion)).filter(p => p !== null);

                    if (layer.type === 'external' || poly.isExternal) {
                        console.log("Calculated pixelPolygon (after filter):", JSON.stringify(pixelPolygon));
                        console.log("Color:", poly.color, "Layer Opacity:", layer.opacity, "Global Alpha Before Poly:", ctx.globalAlpha);
                    }

                    // If, after filtering, not enough points remain for a polygon, skip drawing it.
                    if (pixelPolygon.length < 3) {
                        if (layer.type === 'external' || poly.isExternal) {
                             console.warn(`Skipping polygon ${poly.id} in layer ${layer.name} due to insufficient valid points after transformation (${pixelPolygon.length} points).`);
                        }
                        return; // continue to next polygon
                    }

                    // Get symbology settings for the current layer
                    const layerSymbology = layer.symbology || layers[0].symbology; // Fallback

                    // Since categorized symbology is removed, currentSymbol is directly from layerSymbology
                    const currentSymbol = {
                        fillColor: layerSymbology.fillColor || 'rgba(128,128,128,0.3)',
                        strokeColor: layerSymbology.strokeColor || 'rgba(100,100,100,1)',
                        strokeWidth: layerSymbology.strokeWidth === undefined ? 1 : layerSymbology.strokeWidth,
                        strokeDashArray: layerSymbology.strokeDashArray || []
                    };

                    // Draw fill/mask
                    // The poly.maskImage part is primarily for SAM-generated segments which are single symbol
                    if (poly.maskImage && poly.maskImage.complete) { 
                        ctx.drawImage(poly.maskImage, 0, 0, image.width, image.height);
                        if (isEditingThisPoly) { // Optional: highlight for editing even with mask
                            ctx.beginPath();
                            pixelPolygon.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
                            ctx.closePath();
                            ctx.fillStyle = 'rgba(255, 0, 255, 0.2)'; 
                            ctx.fill();
                        }
                    } else { // Standard fill for non-mask polygons
                        ctx.beginPath();
                        pixelPolygon.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
                        ctx.closePath();
                        
                        ctx.fillStyle = currentSymbol.fillColor;
                        if (isEditingThisPoly) { // Edit highlight for single symbol fill
                            const editFillAlpha = Math.min(1, getRgbaAlpha(currentSymbol.fillColor) + 0.2);
                            ctx.fillStyle = setRgbaAlpha(currentSymbol.fillColor, editFillAlpha);
                        }
                        ctx.fill();
                    }

                    // Draw outline
                    ctx.beginPath();
                    pixelPolygon.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
                    ctx.closePath();

                    ctx.strokeStyle = currentSymbol.strokeColor;
                    ctx.setLineDash(currentSymbol.strokeDashArray);

                    let baseLineWidth = Math.max(0.1, currentSymbol.strokeWidth) / transform.scale;

                    if (isInspectedThisPoly && !isEditingThisPoly) {
                        ctx.strokeStyle = 'rgba(0, 255, 255, 0.9)'; 
                        ctx.lineWidth = (Math.max(currentSymbol.strokeWidth, 1.5) + 1) / transform.scale;
                    } else if (isEditingThisPoly) {
                        ctx.strokeStyle = 'rgba(255, 0, 255, 0.9)'; 
                        ctx.lineWidth = (Math.max(currentSymbol.strokeWidth, 1.5) + 1.5) / transform.scale;
                    } else {
                        ctx.lineWidth = baseLineWidth;
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw vertices if editing this polygon (and it's not an external layer)
                    if (isEditingThisPoly && layer.type !== 'external' && !poly.isExternal) {
                        const vertexRadius = 5 / transform.scale;
                        ctx.fillStyle = 'rgba(255, 0, 255, 0.9)';
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.lineWidth = 1 / transform.scale;
                        pixelPolygon.forEach(vertex => {
                            ctx.beginPath();
                            ctx.arc(vertex.x, vertex.y, vertexRadius, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.stroke();
                        });
                    }
                });
                ctx.globalAlpha = originalAlpha; // Reset globalAlpha to its state before this layer
            });

            ctx.restore(); 

            if (!isEditMode) {
                tempPoints.forEach(p => {
                    ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI); 
                    ctx.fillStyle = p.label === 1 ? 'rgba(74, 222, 128, 0.8)' : 'rgba(239, 68, 68, 0.8)';
                    ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.fill(); ctx.stroke();
                });
                if (tempBox) { 
                    ctx.strokeStyle = 'rgba(79, 70, 229, 0.9)'; ctx.lineWidth = 2;
                    ctx.strokeRect(tempBox.x1, tempBox.y1, tempBox.x2 - tempBox.x1, tempBox.y2 - tempBox.y1);
                }

                if (segmentMode === 'draw_polygon' && currentManualPolygonPoints.length > 0) {
                    ctx.save(); 
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.9)'; 
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(currentManualPolygonPoints[0].x, currentManualPolygonPoints[0].y);
                    for (let i = 1; i < currentManualPolygonPoints.length; i++) {
                        ctx.lineTo(currentManualPolygonPoints[i].x, currentManualPolygonPoints[i].y);
                    }
                    if (currentManualPolygonPoints.length > 0) { 
                        ctx.lineTo(currentMousePos.x, currentMousePos.y);
                    }
                    ctx.stroke();

                    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                    currentManualPolygonPoints.forEach(p => {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                    ctx.restore();
                }
            }
        }


        function previewPixelToGeo(previewX, previewY) { 
            const currentImageSourceType = imageSourceTypeSelect.value;
            const isSnapshot = (image && image.src.startsWith('data:image/'));

            if (isSnapshot) { 
                if (!fullImageShape || !image) {
                     console.error("Cannot convert snapshot pixel to full snapshot coords: Missing fullImageShape or image.");
                     return null;
                }
                const scaleXFactor = fullImageShape.width / image.width;
                const scaleYFactor = fullImageShape.height / image.height;
                const snapshotX = previewX * scaleXFactor;
                const snapshotY = previewY * scaleYFactor;
                
                if (currentSnapshotGCPData && currentSnapshotGCPData.pixel_gcps.length > 0) {
                    return [snapshotX, snapshotY];
                }
                return [snapshotX, snapshotY]; 
            }

            if (!geoTransformParams || !fullImageShape || !image) {
                console.error("Cannot convert pixel to geo: Missing geoTransformParams, fullImageShape, or image.");
                return null;
            }

            const scaleXFactor = fullImageShape.width / image.width;    
            const scaleYFactor = fullImageShape.height / image.height;  
            const fullImageX = previewX * scaleXFactor;
            const fullImageY = previewY * scaleYFactor;

            const [A, B, C, D, E, F] = geoTransformParams;
            const geoX = C + fullImageX * A + fullImageY * B;
            const geoY = F + fullImageX * D + fullImageY * E;

            return [geoX, geoY];
        }
        
        function geoToPixel(geoPoint, isGeographic = true) {
            if (!fullImageShape || !image) {
                // This case implies no base image is loaded, so geo-coords cannot be reliably converted to pixels.
                // console.warn("geoToPixel: Missing fullImageShape or image. Cannot transform point.");
                return null; 
            }

            let x_full_pix, y_full_pix;

            if (isGeographic) {
                if (!geoTransformParams) {
                    console.warn("geoToPixel: geoTransformParams not available for a geographic point. Cannot transform.");
                    return null; 
                }
                // Check for plain snapshot context (identity transform) when dealing with geographic input
                const isSnapshotBase = (imageSourceTypeSelect.value === '3dmap' || (image && image.src && image.src.startsWith('data:image/')));
                if (isSnapshotBase && isEffectivelyIdentity(geoTransformParams) && !currentSnapshotGCPData) { 
                    // This condition checks if it's a snapshot, transform is identity, AND no GCP data is available/processed for drawing
                    // (The !currentSnapshotGCPData is a proxy for "GCPs are not being used to define the transform for drawing this layer")
                    console.warn("geoToPixel: Attempting to display geographic layer on a non-georeferenced snapshot. Coordinates may not align. Load a georeferenced base image or use GCPs with the snapshot for proper alignment.");
                    // For now, we still attempt the transform, but it will effectively treat geo-coords as pixels.
                    // To truly prevent drawing, we'd return null here.
                    // Let's return null to prevent mis-drawing.
                    return null;
                }

                const [A, B, C, D, E, F] = geoTransformParams;
                const [x_geo, y_geo] = geoPoint;
                const det = A * E - B * D;
                if (det === 0) {
                    console.warn("geoToPixel: Affine transform determinant is zero. Cannot transform.");
                    return null;
                }
                const idet = 1 / det;
                x_full_pix = (E * (x_geo - C) - B * (y_geo - F)) * idet;
                y_full_pix = (-D * (x_geo - C) + A * (y_geo - F)) * idet;
            } else {
                [x_full_pix, y_full_pix] = geoPoint;
            }
            
            const scaleX = image.width / fullImageShape.width;
            const scaleY = image.height / fullImageShape.height;
            
            return { x: x_full_pix * scaleX, y: y_full_pix * scaleY };
        }

        function pixelToGeo(canvasX, canvasY) {
            if (!selectedPolygonForEdit) {
                console.warn("pixelToGeo called without selectedPolygonForEdit.");
                return null;
            }

            // Determine if we should be working in pixel coordinates for the purpose of this conversion
            // This is true if the polygon is not geographic OR if it's GCP-derived (where we edit its pixel representation)
            const convertToPixelCoords = !selectedPolygonForEdit.isGeographic || selectedPolygonForEdit.isGcpDerived;

            if (convertToPixelCoords) { // Path for returning full-resolution snapshot pixel coordinates
                if (!fullImageShape || !image) { 
                    console.error("pixelToGeo (pixel mode): Missing fullImageShape or image for pixel conversion.");
                    return null;
                }
                const previewX = (canvasX - transform.x) / transform.scale;
                const previewY = (canvasY - transform.y) / transform.scale;

                const scaleXFactor = fullImageShape.width / image.width; 
                const scaleYFactor = fullImageShape.height / image.height;
                const snapshotX = previewX * scaleXFactor;
                const snapshotY = previewY * scaleYFactor;
                return [snapshotX, snapshotY]; // Returns [full_pixel_x, full_pixel_y]
            } else { // Path for returning true geographic coordinates (e.g., for ortho, satellite)
                if (!geoTransformParams || !fullImageShape || !image) {
                    console.error("pixelToGeo (geographic mode): Missing geoTransformParams, fullImageShape, or image.");
                    return null;
                }
                // ... (identical logic as before for geographic conversion)
                const previewX = (canvasX - transform.x) / transform.scale;
                const previewY = (canvasY - transform.y) / transform.scale;
                const scaleX = fullImageShape.width / image.width;    
                const scaleY = fullImageShape.height / image.height;  
                const fullImageX = previewX * scaleX;
                const fullImageY = previewY * scaleY;
                const [A, B, C, D, E, F] = geoTransformParams;
                const geoX = C + fullImageX * A + fullImageY * B;
                const geoY = F + fullImageX * D + fullImageY * E;
                return [geoX, geoY];
            }
        }

        function getMousePosOnCanvas(e) { const rect = canvas.getBoundingClientRect(); return { x: e.clientX - rect.left, y: e.clientY - rect.top }; }
        function resetTransform() { if (!image) return; const rect = canvasContainer.getBoundingClientRect(); transform.scale = Math.min(rect.width / image.width, rect.height / image.height); transform.x = (rect.width - image.width * transform.scale) / 2; transform.y = (rect.height - image.height * transform.scale) / 2; }
        
        function applyZoom(scaleFactor, mouseX, mouseY) {
            if (!image) return;
            const rect = canvas.getBoundingClientRect();
            const clientX = mouseX === undefined ? rect.left + rect.width / 2 : mouseX;
            const clientY = mouseY === undefined ? rect.top + rect.height / 2 : mouseY;

            const canvasMouseX = clientX - rect.left;
            const canvasMouseY = clientY - rect.top;

            transform.x = canvasMouseX - (canvasMouseX - transform.x) * scaleFactor;
            transform.y = canvasMouseY - (canvasMouseY - transform.y) * scaleFactor;
            transform.scale *= scaleFactor;
            draw();
        }

        function handleWheel(e) {
            e.preventDefault();
            const zoomIntensity = 0.1;
            const scaleFactor = e.deltaY > 0 ? 1 - zoomIntensity : 1 + zoomIntensity;
            applyZoom(scaleFactor, e.clientX, e.clientY);
        }
        
        function updateLayerPane() { // Renamed from updatePolygonList
            layerListEl.innerHTML = ''; 
            
            let hasAnyPolygons = false;
            layers.forEach(layer => {
                if (layer.polygons && layer.polygons.length > 0) {
                    hasAnyPolygons = true;
                }

                const layerItem = document.createElement('li');
                // Added 'layer-item' class for potential shared styling or JS selection
                layerItem.className = 'layer-item p-2 rounded-md border dark:border-slate-700 bg-slate-50 dark:bg-slate-700/50 space-y-1'; // Removed cursor-grab for now, will add to specific handle
                layerItem.setAttribute('data-layer-id', layer.id); // Keep data-layer-id for remove/opacity etc.
                
                const checkboxId = `visibility-toggle-${layer.id}`;
                const expandIcon = layer.isExpanded ? '▾' : '▸';

                let polygonsHtml = '';
                if (layer.isExpanded && layer.polygons && layer.polygons.length > 0) {
                    polygonsHtml += '<ul class="ml-4 mt-1 space-y-1 border-l border-slate-200 dark:border-slate-600 pl-2 py-1">';
                    layer.polygons.forEach(poly => {
                        const isSelectedForInspection = poly.id === selectedPolygonIdForInspection;
                        const polygonItemClasses = `text-xs flex justify-between items-center p-1 rounded hover:bg-indigo-100 dark:hover:bg-slate-600 ${isSelectedForInspection ? 'selected-for-inspection' : ''}`;
                        
                        polygonsHtml += `
                            <li class="${polygonItemClasses}" data-polygon-id="${poly.id}" data-parent-layer-id="${layer.id}" style="cursor: default;">
                                <span class="truncate polygon-list-item-name" title="Polygon ${poly.id}">Polygon ${poly.id}</span>
                                <div class="space-x-1 flex-shrink-0">
                                    <button class="inspect-polygon-btn p-0.5 rounded text-slate-500 hover:text-sky-600 dark:text-slate-400 dark:hover:text-sky-400" title="Inspect Properties">
                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
                                    </button>
                                    ${(!poly.isExternal && layer.type !== 'external') ? `
                                    <button class="edit-polygon-btn p-0.5 rounded text-slate-500 hover:text-indigo-600 dark:text-slate-400 dark:hover:text-indigo-400" title="Edit Polygon">
                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>
                                    </button>` : ''}
                                    <button class="delete-polygon-btn p-0.5 rounded text-slate-500 hover:text-red-600 dark:text-slate-400 dark:hover:text-red-400" title="Delete Polygon">
                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                    </button>
                                </div>
                            </li>`;
                    });
                    polygonsHtml += '</ul>';
                } else if (layer.isExpanded && (!layer.polygons || layer.polygons.length === 0)) {
                     polygonsHtml = '<div class="ml-6 text-xs text-slate-500 dark:text-slate-400 italic">No polygons in this layer.</div>';
                }


                layerItem.innerHTML = `
                    <div class="flex items-center justify-between">
                        <div class="flex items-center">
                            <span class="expand-layer-icon mr-1 cursor-pointer text-slate-500 dark:text-slate-400 hover:text-indigo-600 dark:hover:text-indigo-300" data-layer-id="${layer.id}">${expandIcon}</span>
                            <input type="checkbox" id="${checkboxId}" data-layer-id="${layer.id}" class="visibility-checkbox h-4 w-4 text-indigo-600 border-slate-300 rounded focus:ring-indigo-500 mr-2 dark:bg-slate-600 dark:border-slate-500 dark:checked:bg-indigo-500" ${layer.visible ? 'checked' : ''}>
                            <label for="${checkboxId}" class="text-sm font-semibold text-slate-800 dark:text-slate-200 cursor-pointer layer-name-label" data-layer-id="${layer.id}" draggable="true">${layer.name}</label>
                        </div>
                            <label for="${checkboxId}" class="text-sm font-semibold text-slate-800 dark:text-slate-200 cursor-pointer layer-name-label" data-layer-id="${layer.id}" draggable="true">${layer.name}</label>
                        </div>
                        <div class="flex items-center space-x-1">
                            <button data-layer-id="${layer.id}" class="edit-symbology-btn p-0.5 rounded text-slate-500 hover:text-purple-600 dark:text-slate-400 dark:hover:text-purple-400" title="Edit Symbology">
                                <svg class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" /><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd" /></svg>
                            </button>
                            <button data-layer-id="${layer.id}" class="zoom-to-layer-btn p-0.5 rounded text-slate-500 hover:text-blue-600 dark:text-slate-400 dark:hover:text-blue-400 disabled:opacity-50 disabled:cursor-not-allowed" title="Zoom to Layer Extent" ${!(image || imageSourceTypeSelect.value === '3dmap') ? 'disabled' : ''}>
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 10L3 3"></path></svg>
                            </button>
                            ${ (layer.type === 'segmentation') ? `
                            <button data-layer-id="${layer.id}" class="clear-layer-polygons-btn p-0.5 rounded text-slate-500 hover:text-orange-600 dark:text-slate-400 dark:hover:text-orange-400 disabled:opacity-50 disabled:cursor-not-allowed" title="Clear Polygons in Layer" ${!image ? 'disabled' : ''}>
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            </button>` : ''}
                            ${layer.deletable ? `
                            <button data-layer-id="${layer.id}" class="remove-layer-btn p-1 rounded-md hover:bg-red-100 text-slate-500 hover:text-red-600 dark:hover:bg-slate-600 dark:text-slate-400 dark:hover:text-red-400" title="Remove Layer">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                            </button>` : ''}
                        </div>
                    </div>
                    <div class="mt-1 ml-6"> 
                        <label for="opacity-slider-${layer.id}" class="text-xs text-slate-600 dark:text-slate-400">Opacity: <span id="opacity-value-${layer.id}">${Math.round(layer.opacity * 100)}%</span></label>
                        <input type="range" id="opacity-slider-${layer.id}" data-layer-id="${layer.id}" min="0" max="1" step="0.05" value="${layer.opacity}" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer dark:bg-slate-700 layer-opacity-slider">
                    </div>
                    ${polygonsHtml}
                `;
                layerListEl.appendChild(layerItem);

                // Drag and Drop Event Listeners for the layer name label (making only name draggable)
                const draggablePart = layerItem.querySelector('.layer-name-label');
                if(draggablePart) { // Check because default layer might not have this if we change structure
                    draggablePart.addEventListener('dragstart', (e) => {
                        // To prevent checkbox/slider from interfering with drag, stop propagation if target is not the label
                        if (e.target !== draggablePart) { 
                            // e.stopPropagation(); // This might be too aggressive
                            return; 
                        }
                        draggedLayerId = layer.id; 
                        e.dataTransfer.setData('text/plain', layer.id);
                        layerItem.classList.add('dragging'); // Style the whole item
                    });
                }
                // The layerItem itself is the drop target
                layerItem.addEventListener('dragstart', (e) => {
                    draggedLayerId = layer.id; // Using global var for simplicity
                    e.dataTransfer.setData('text/plain', layer.id);
                    e.currentTarget.classList.add('dragging');
                });

                layerItem.addEventListener('dragover', (e) => {
                    e.preventDefault(); // Necessary to allow dropping
                    e.currentTarget.classList.add('drag-over-target');
                });

                layerItem.addEventListener('dragleave', (e) => {
                    e.currentTarget.classList.remove('drag-over-target');
                });

                layerItem.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over-target');
                    const targetLayerId = layer.id; // The layer it's dropped ON
                    if (draggedLayerId && draggedLayerId !== targetLayerId) {
                        reorderLayers(draggedLayerId, targetLayerId);
                    }
                    draggedLayerId = null; // Reset
                });

                layerItem.addEventListener('dragend', (e) => {
                    e.currentTarget.classList.remove('dragging');
                    // Clean up any lingering drag-over-target classes if drop didn't happen on a valid target
                    document.querySelectorAll('.layer-item.drag-over-target').forEach(el => el.classList.remove('drag-over-target'));
                    draggedLayerId = null; // Reset
                });
                 // Drop target for the layer item itself
                layerItem.addEventListener('dragover', (e) => {
                    e.preventDefault(); 
                    layerItem.classList.add('drag-over-target');
                });
                layerItem.addEventListener('dragleave', (e) => {
                    layerItem.classList.remove('drag-over-target');
                });
                layerItem.addEventListener('drop', (e) => {
                    e.preventDefault();
                    layerItem.classList.remove('drag-over-target');
                    const targetLayerId = layer.id; 
                    if (draggedLayerId && draggedLayerId !== targetLayerId) {
                        reorderLayers(draggedLayerId, targetLayerId);
                    }
                    draggedLayerId = null; 
                });
                layerItem.addEventListener('dragend', (e) => { // This might be better on draggablePart
                    layerItem.classList.remove('dragging');
                    document.querySelectorAll('.layer-item.drag-over-target').forEach(el => el.classList.remove('drag-over-target'));
                    draggedLayerId = null;
                });
            });

            downloadBtn.disabled = !hasAnyPolygons;
            downloadShapefileBtn.disabled = !hasAnyPolygons;

            // --- Event Listeners for dynamic content ---

            // Layer Visibility
            document.querySelectorAll('.visibility-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    const layerId = e.target.dataset.layerId;
                    const changedLayer = layers.find(l => l.id === layerId);
                    if (changedLayer) {
                        changedLayer.visible = e.target.checked;

                        // If Google Map is active, update features visibility on it
                        if (googleMap && imageSourceTypeSelect.value === '3dmap') {
                            // Clear all currently displayed map.data features
                            googleMap.data.forEach(feature => {
                                googleMap.data.remove(feature);
                            });
                            // Re-add GeoJSON for all *now visible* layers that have mapDataGeoJson
                            layers.forEach(layer => {
                                if (layer.visible && layer.mapDataGeoJson && layer.type === 'external') {
                                    googleMap.data.addGeoJson(layer.mapDataGeoJson);
                                    // Re-apply style (or rely on a global style if set, but addGeoJson might clear it)
                                    // For simplicity, the style set in loadExternalGeoJSON should apply to newly added data.
                                    // Or, we can re-apply a generic style here too.
                                    // Let's assume the style applied when loading is sufficient for now,
                                    // or Google Maps Data layer retains style per feature.
                                    // To be safe, we can re-apply a generic style or the specific layer's style if stored.
                                }
                            });
                             // Re-apply a general style to all features on the map after add/remove operations
                            googleMap.data.setStyle(feature => {
                                const color = feature.getProperty('color') || 'rgba(0, 0, 255, 1)';
                                let fillOpacity = 0.3;
                                let finalFillColor = `rgba(0,0,255,${fillOpacity})`;
                                try {
                                    const colorParts = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([0-9.]+))?\)/);
                                    if (colorParts) {
                                        finalFillColor = `rgba(${colorParts[1]}, ${colorParts[2]}, ${colorParts[3]}, ${fillOpacity})`;
                                    }
                                } catch(e) { /* use default */ }
                                return { fillColor: finalFillColor, strokeColor: feature.getProperty('color') || 'rgba(0,0,150,1)', strokeWeight: 1, clickable: false };
                            });
                        }
                        draw(); // Redraw canvas (for snapshots)
                    }
                });
            });

            // Remove Layer
            document.querySelectorAll('.remove-layer-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const layerIdToRemove = e.currentTarget.dataset.layerId;
                    const layerToRemove = layers.find(l=>l.id === layerIdToRemove);
                    if (confirm(`Are you sure you want to remove layer "${layerToRemove?.name}"? Its polygons will be deleted.`)) {
                        layers = layers.filter(l => l.id !== layerIdToRemove);
                        if (selectedPolygonForEdit && (!layers.find(l => l.polygons.includes(selectedPolygonForEdit)))) {
                            exitEditMode(false); 
                        }
                        if (selectedPolygonIdForInspection && (!layers.find(l => l.polygons.find(p => p.id === selectedPolygonIdForInspection)))) {
                            selectedPolygonIdForInspection = null;
                        }
                        updateLayerPane();
                        draw();
                    }
                });
            });

            // Layer Opacity
            document.querySelectorAll('.layer-opacity-slider').forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const layerId = e.target.dataset.layerId;
                    const opacityValue = parseFloat(e.target.value);
                    const layer = layers.find(l => l.id === layerId);
                    if (layer) {
                        layer.opacity = opacityValue;
                        const valueDisplay = document.getElementById(`opacity-value-${layerId}`);
                        if (valueDisplay) valueDisplay.textContent = `${Math.round(opacityValue * 100)}%`;
                        draw(); 
                    }
                });
            });

            // Expand/Collapse Layer
            document.querySelectorAll('.expand-layer-icon').forEach(icon => {
                icon.addEventListener('click', (e) => {
                    const layerId = e.currentTarget.dataset.layerId;
                    const layer = layers.find(l => l.id === layerId);
                    if (layer) {
                        layer.isExpanded = !layer.isExpanded;
                        updateLayerPane(); // Re-render to show/hide polygons
                    }
                });
            });

            // Polygon Item Click (for selection/highlighting)
            document.querySelectorAll('#layer-list ul li[data-polygon-id]').forEach(item => {
                item.addEventListener('click', (e) => {
                    // Prevent event from bubbling to layer item if necessary, though not strictly needed here
                    // e.stopPropagation(); 
                    const polygonId = e.currentTarget.dataset.polygonId;
                    // const parentLayerId = e.currentTarget.dataset.parentLayerId; // Available if needed
                    
                    if (selectedPolygonIdForInspection === polygonId) {
                        // Optional: click again to deselect, or do nothing
                        // selectedPolygonIdForInspection = null; 
                    } else {
                        selectedPolygonIdForInspection = polygonId;
                    }
                    updateLayerPane(); // Re-render to update selection highlight in list
                    draw(); // Re-render canvas to update highlight on map
                });
            });

            // Inspect Polygon Button
            document.querySelectorAll('.inspect-polygon-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent click on parent LI
                    const listItem = e.currentTarget.closest('li[data-polygon-id]');
                    const polygonId = listItem.dataset.polygonId;
                    const parentLayerId = listItem.dataset.parentLayerId;
                    const layer = layers.find(l => l.id === parentLayerId);
                    const poly = layer?.polygons.find(p => p.id.toString() === polygonId); // Ensure ID comparison is robust

                    if (poly) {
                        selectedPolygonIdForInspection = poly.id;
                        let propertiesString = `Polygon ID: ${poly.id}\nLayer: ${layer.name}\nProperties:\n`;
                        if (poly.properties && Object.keys(poly.properties).length > 0) {
                            for (const key in poly.properties) {
                                propertiesString += `  ${key}: ${JSON.stringify(poly.properties[key])}\n`;
                            }
                        } else {
                            propertiesString += "  (No additional properties)";
                        }
                        alert(propertiesString);
                        updateLayerPane();
                        draw();
                    }
                });
            });

            // Delete Polygon Button
            document.querySelectorAll('.delete-polygon-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const listItem = e.currentTarget.closest('li[data-polygon-id]');
                    const polygonId = listItem.dataset.polygonId;
                    const parentLayerId = listItem.dataset.parentLayerId;
                    const layer = layers.find(l => l.id === parentLayerId);
                    const polyIndex = layer?.polygons.findIndex(p => p.id.toString() === polygonId);

                    if (layer && polyIndex !== -1) {
                        if (confirm(`Delete Polygon ${polygonId} from layer "${layer.name}"?`)) {
                            const deletedPoly = layer.polygons.splice(polyIndex, 1)[0];
                            if (selectedPolygonForEdit && selectedPolygonForEdit.id === deletedPoly.id) {
                                exitEditMode(false); // Cancel edit if it was this polygon
                            }
                            if (selectedPolygonIdForInspection === deletedPoly.id) {
                                selectedPolygonIdForInspection = null;
                            }
                            updateLayerPane();
                            draw();
                        }
                    }
                });
            });
            
            // Zoom to Layer Extent Button
            document.querySelectorAll('.zoom-to-layer-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const layerId = e.currentTarget.dataset.layerId;
                    zoomToLayerExtent(layerId);
                });
            });

            // Clear Polygons from Layer Button
            document.querySelectorAll('.clear-layer-polygons-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const layerId = e.currentTarget.dataset.layerId;
                    clearPolygonsFromLayer(layerId);
                });
            });
            
            // Edit Polygon Button
            document.querySelectorAll('.edit-polygon-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const listItem = e.currentTarget.closest('li[data-polygon-id]');
                    const polygonId = listItem.dataset.polygonId;
                    const parentLayerId = listItem.dataset.parentLayerId;
                    const layer = layers.find(l => l.id === parentLayerId);
                    const poly = layer?.polygons.find(p => p.id.toString() === polygonId);

                    if (poly && !poly.isExternal && layer.type !== 'external') {
                        await enterEditModeForPolygon(poly);
                    }
                });
            });
            
            // Note: Individual polygon edit/inspect/delete buttons are removed for this phase. // This comment is now outdated
            // Double-click to edit will still work for non-external polygons.
            // Select mode will still work for inspection highlighting.
            // Need to re-evaluate how to best integrate individual polygon management within the layer pane UI in a future phase.
        }

        function zoomToLayerExtent(layerId) {
            const layer = layers.find(l => l.id === layerId);
            if (!layer || !layer.polygons || layer.polygons.length === 0) {
                console.log("Zoom to Layer: Layer not found or has no polygons.", layerId);
                alert("Layer has no polygons to zoom to.");
                return;
            }

            // Scenario 1: Live Google Map is active, no snapshot on canvas yet
            if (imageSourceTypeSelect.value === '3dmap' && !image && googleMap) {
                console.log("Zoom to Layer: Attempting to zoom on live Google Map for layer:", layer.name);
                const bounds = new google.maps.LatLngBounds();
                let pointsAddedToBounds = 0;

                layer.polygons.forEach(poly => {
                    if (poly.isGeographic && poly.points && poly.points.length > 0) {
                        poly.points.forEach(p => {
                            if (Array.isArray(p) && p.length === 2 && typeof p[0] === 'number' && typeof p[1] === 'number') {
                                bounds.extend(new google.maps.LatLng(p[1], p[0])); // Lat, Lng for Google Maps
                                pointsAddedToBounds++;
                            } else {
                                console.warn("Zoom to Layer (Map): Skipping malformed geographic point in polygon", poly.id, "point:", p);
                            }
                        });
                    } else if (!poly.isGeographic) {
                        console.warn("Zoom to Layer (Map): Skipping non-geographic polygon", poly.id, "as map zoom requires geographic coordinates.");
                    }
                });

                if (pointsAddedToBounds > 0) {
                    googleMap.fitBounds(bounds);
                    console.log("Zoom to Layer: Google Map view adjusted for layer:", layer.name);
                } else {
                    alert("Cannot zoom to this layer on the map: No valid geographic points found in the layer.");
                    console.log("Zoom to Layer (Map): No valid geographic points to create bounds for layer:", layer.name);
                }
                return; // Handled map zoom
            }

            // Scenario 2: Canvas with a loaded image is active (Orthophoto, Satellite, or Snapshot)
            if (!image || !fullImageShape) { // This check is now for the canvas/SAM image context
                alert("Please load a base image (Orthophoto, Satellite, or Snapshot) before zooming to a layer on the canvas.");
                console.log("Zoom to Layer (Canvas): Aborted because no base image or fullImageShape is loaded for canvas.");
                return;
            }

            // Proceed with existing canvas zooming logic
            console.log("Zoom to Layer: Using canvas zoom logic for layer:", layer.name);
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            let hasValidPoints = false;

            layer.polygons.forEach(poly => {
                let pointsToProcess = [];
                // Prioritize pixelPoints if they exist and are suitable (e.g. for GCP derived)
                // However, geoToPixel expects geographic input if isGeographic is true.
                // For zoom-to-layer, we need all points in a consistent coordinate space,
                // ideally the preview image's pixel space, as that's what geoToPixel outputs.
                
                const currentPoints = (poly.isGcpDerived && poly.pixelPoints) ? poly.pixelPoints : poly.points;
                const isGeo = (poly.isGcpDerived && poly.pixelPoints) ? false : poly.isGeographic;


                currentPoints.forEach(point => {
                    const pixelPoint = geoToPixel(point, isGeo); // geoToPixel handles if 'point' is already pixel via 'isGeo'
                    if (pixelPoint) { // geoToPixel now returns null on failure
                        minX = Math.min(minX, pixelPoint.x);
                        minY = Math.min(minY, pixelPoint.y);
                        maxX = Math.max(maxX, pixelPoint.x);
                        maxY = Math.max(maxY, pixelPoint.y);
                        hasValidPoints = true;
                    }
                });
            });

            if (!hasValidPoints) {
                console.log("Zoom to Layer: No valid points found in layer to calculate extent.", layerId);
                alert("Cannot zoom to layer: No valid point data found.");
                return;
            }

            const paddingPercentage = 0.15; // 15% padding
            let bboxWidth = maxX - minX;
            let bboxHeight = maxY - minY;

            if (bboxWidth === 0 && bboxHeight === 0 && layer.polygons.length === 1 && layer.polygons[0].points.length === 1) {
                 // Single point polygon, give it a default extent for zooming
                const pointSizeOnCanvas = 50; // Target size of the point on canvas in pixels
                const currentPointPixel = {x: minX, y: minY}; // The single point
                
                transform.scale = 1; // Start with a known scale to determine pixel size relation if needed, or just use a fixed zoom.
                                     // For simplicity, let's set a fixed scale that makes a point reasonably visible.
                                     // This is tricky because geoToPixel gives preview image pixels, not canvas pixels directly yet.
                                     // Let's assume for a single point, we set a moderate zoom level centered on it.
                                     // This part requires careful thought on how to define "zoom to a single point".
                                     // Alternative: create a small bounding box around the point.
                const defaultExtentSize = image ? Math.min(image.width, image.height) * 0.1 : 100; // 10% of image, or 100px
                bboxWidth = defaultExtentSize;
                bboxHeight = defaultExtentSize;
                minX -= defaultExtentSize / 2;
                minY -= defaultExtentSize / 2;
                maxX += defaultExtentSize / 2; // This redefines maxX, bboxWidth needs recalculation
                maxY += defaultExtentSize / 2;
                bboxWidth = maxX - minX; // Recalculate
                bboxHeight = maxY - minY;

            } else {
                 if (bboxWidth === 0) bboxWidth = canvasContainer.clientWidth * 0.1; // Default small width if all points are collinear vertically
                 if (bboxHeight === 0) bboxHeight = canvasContainer.clientHeight * 0.1; // Default small height if all points are collinear horizontally
            }


            const containerWidth = canvasContainer.clientWidth;
            const containerHeight = canvasContainer.clientHeight;

            const scaleX = containerWidth / (bboxWidth * (1 + paddingPercentage * 2));
            const scaleY = containerHeight / (bboxHeight * (1 + paddingPercentage * 2));
            
            transform.scale = Math.min(scaleX, scaleY);
            if (transform.scale <= 0 || !isFinite(transform.scale)) { // Safety check for scale
                console.warn("Zoom to Layer: Calculated invalid scale", transform.scale, "defaulting to 1.");
                transform.scale = 1; 
            }


            // Center the bounding box on the canvas
            // transform.x is the canvas pixel offset for the top-left of the *preview image*
            // transform.y is the canvas pixel offset for the top-left of the *preview image*
            // minX, minY, bboxWidth, bboxHeight are in *preview image pixel coordinates*
            
            transform.x = (containerWidth / 2) - ((minX + bboxWidth / 2) * transform.scale);
            transform.y = (containerHeight / 2) - ((minY + bboxHeight / 2) * transform.scale);
            
            console.log(`Zooming to layer ${layer.name}: Scale=${transform.scale}, X=${transform.x}, Y=${transform.y}`);
            draw();
        }

        function clearPolygonsFromLayer(layerId) {
            const layer = layers.find(l => l.id === layerId);
            if (!layer) {
                console.error("Clear Polygons: Layer not found", layerId);
                return;
            }

            if (confirm(`Are you sure you want to clear all polygons from layer "${layer.name}"? This cannot be undone.`)) {
                // Clear polygons from the specific layer
                layer.polygons = [];

                // If the currently edited or inspected polygon was in this layer, clear those states
                if (selectedPolygonForEdit && layers.every(l => !l.polygons.find(p => p.id === selectedPolygonForEdit.id))) {
                    // More direct check: if selectedPolygonForEdit was in the layer being cleared
                    let foundInOtherLayer = false;
                    for(let otherLayer of layers) {
                        if(otherLayer.id !== layerId && otherLayer.polygons.some(p => p.id === selectedPolygonForEdit.id)) {
                            foundInOtherLayer = true;
                            break;
                        }
                    }
                    if(!foundInOtherLayer) exitEditMode(false); // Cancel edit if its polygon's layer is cleared
                }
                
                let inspectionCleared = false;
                if (selectedPolygonIdForInspection) {
                    let foundInOtherLayerForInspection = false;
                     for(let otherLayer of layers) {
                        if(otherLayer.id !== layerId && otherLayer.polygons.some(p => p.id === selectedPolygonIdForInspection)) {
                            foundInOtherLayerForInspection = true;
                            break;
                        }
                    }
                    if(!foundInOtherLayerForInspection) {
                        selectedPolygonIdForInspection = null;
                        inspectionCleared = true;
                    }
                }
                
                console.log(`Cleared all polygons from layer "${layer.name}".`);
                updateLayerPane(); // Refresh the layer list (should show "No polygons..." if expanded)
                draw(); // Refresh the canvas
            }
        }

        function reorderLayers(draggedId, targetId) {
            const draggedIndex = layers.findIndex(layer => layer.id === draggedId);
            const targetIndex = layers.findIndex(layer => layer.id === targetId);

            if (draggedIndex === -1 || targetIndex === -1 || draggedIndex === targetIndex) {
                console.warn("Layer reorder aborted: invalid IDs or same layer.");
                return;
            }

            // Remove the dragged layer from its original position
            const [draggedLayer] = layers.splice(draggedIndex, 1);

            // Insert it at the target position (adjusting if necessary)
            // If draggedIndex was before targetIndex, the targetIndex effectively shifts left by 1
            const adjustedTargetIndex = draggedIndex < targetIndex ? targetIndex -1 : targetIndex;
            
            layers.splice(adjustedTargetIndex, 0, draggedLayer);

            console.log(`Reordered layers. New order:`, layers.map(l => l.name));
            updateLayerPane(); // Re-render the UI list
            draw(); // Re-draw the canvas
        }

        async function exitEditMode(saveChanges = true) { 
            if (!isEditMode || !selectedPolygonForEdit) {
                isEditMode = false; // Ensure state is reset even if called unexpectedly
                selectedPolygonForEdit = null;
                originalPolygonPoints = null;
                originalPixelPoints = null;
                draggedVertexIndex = null;
                return;
            }

            const polygonBeingExited = selectedPolygonForEdit; // Keep a reference

            if (saveChanges && polygonBeingExited.isGcpDerived) {
                // For GCP-derived polygons, edited pixelPoints need retransformation
                const success = await retransformAndUpdateGcpPolygon(polygonBeingExited);
                if (!success) {
                    // Retransformation failed, changes to .points (geo) were not made.
                    // User was alerted by retransformAndUpdateGcpPolygon.
                    // Decide if we should still exit edit mode or allow user to retry/cancel.
                    // For now, we will still exit, but the geo points are not updated.
                    // The pixelPoints edits are still in polygonBeingExited.pixelPoints.
                    console.warn(`Exiting edit mode for GCP polygon ${polygonBeingExited.id}, but geographic retransformation failed.`);
                }
            } else if (!saveChanges && originalPolygonPoints && selectedPolygonForEdit) {
                // Revert changes directly on the selectedPolygonForEdit object
                selectedPolygonForEdit.points = JSON.parse(JSON.stringify(originalPolygonPoints));
                if (selectedPolygonForEdit.isGcpDerived && originalPixelPoints) {
                    selectedPolygonForEdit.pixelPoints = JSON.parse(JSON.stringify(originalPixelPoints));
                }
                // No need to find it in a list, as selectedPolygonForEdit is a direct reference.
            }
            // If saveChanges is true for non-GCP polygons, the edits are already in selectedPolygonForEdit.points

            isEditMode = false;
            selectedPolygonForEdit = null;
            originalPolygonPoints = null;
            originalPixelPoints = null; // Clear this too
            draggedVertexIndex = null;

            updateCursorBasedOnMode(); 
            canvasContainer.classList.remove('panning'); 

            samPromptButtons.classList.remove('hidden');
            editModeButtons.classList.add('hidden');
            editModeInstructions.classList.add('hidden');
            pointInstructions.classList.toggle('hidden', segmentMode !== 'point');
            boxInstructions.classList.toggle('hidden', segmentMode !== 'box' && segmentMode !== 'draw_polygon'); // Also hide for draw_polygon
            drawPolygonInstructions.classList.toggle('hidden', segmentMode !== 'draw_polygon');
            segmentControls.classList.add('border-slate-200');
            segmentControls.classList.remove('border-blue-300', 'ring-1', 'ring-blue-300');

            document.querySelectorAll('#polygon-list li').forEach(item => item.classList.remove('ring-2', 'ring-indigo-500', 'bg-indigo-50'));
            console.log(`Exited edit mode for polygon ${polygonBeingExited.id}. Save changes: ${saveChanges}`);
            draw();
        }
        
        async function retransformAndUpdateGcpPolygon(polygon) {
            if (!polygon || !polygon.isGcpDerived || !polygon.pixelPoints || !currentSnapshotGCPData) {
                console.error("retransformAndUpdateGcpPolygon: Invalid inputs or not a GCP-derived polygon.", polygon, currentSnapshotGCPData);
                alert("Could not retransform polygon: missing necessary data.");
                return false; // Indicate failure
            }

            loaderOverlay.classList.remove('hidden');
            loaderOverlay.querySelector('p').textContent = 'Updating geographic coordinates...';

            try {
                const payload = {
                    pixel_polygon_full_res: polygon.pixelPoints,
                    gcp_data: currentSnapshotGCPData // Send the GCPs used for the original snapshot
                };
                const response = await fetch(`${BACKEND_URL}/retransform_gcp_polygon`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload),
                });

                const data = await response.json();
                if (!response.ok) {
                    throw new Error(data.error || `Failed with status ${response.status}`);
                }

                if (data.geo_polygon) {
                    polygon.points = data.geo_polygon; // Update the main geographic points
                    console.log(`Polygon ${polygon.id} retransformed successfully.`);
                    return true; // Indicate success
                } else {
                    throw new Error("Retransformation did not return a valid geo_polygon.");
                }
            } catch (error) {
                console.error(`Error retransforming polygon ${polygon.id}:`, error);
                alert(`Failed to update geographic coordinates for polygon ${polygon.id}: ${error.message}`);
                return false; // Indicate failure
            } finally {
                loaderOverlay.classList.add('hidden');
            }
        }

        function downloadGeoJSON() {
            try { 
                const defaultFilename = "georeferenced_polygons.geojson";
                let filename = prompt("Enter filename for the GeoJSON file:", defaultFilename);

                if (filename === null) {
                    console.log("GeoJSON download cancelled by user.");
                    return;
                }
                if (!filename.trim()) {
                    filename = defaultFilename;
                }
                if (!filename.toLowerCase().endsWith('.geojson')) {
                    filename += '.geojson';
                }

                console.log("Preparing GeoJSON data for download...");

                let features = [];
                layers.forEach(layer => {
                    if (layer.visible && layer.polygons) {
                        layer.polygons.forEach(p => {
                            let coordinates = [];
                            if (p.points && Array.isArray(p.points) && p.points.length >= 3) {
                                const firstPoint = p.points[0];
                                const lastPoint = p.points[p.points.length - 1];
                                coordinates = [...p.points.map(pt => [...pt])]; 
                                
                                if (!Array.isArray(firstPoint) || !Array.isArray(lastPoint) || firstPoint.length < 2 || lastPoint.length < 2) {
                                     console.warn(`Polygon ${p.id} in layer ${layer.name} has malformed points, skipping its geometry.`);
                                     features.push({
                                        "type": "Feature",
                                        "geometry": null,
                                        // Merge polygon's own properties, then add/override specific ones
                                        "properties": { ...(p.properties || {}), "id": p.id, "color": p.color, "isGeographic": p.isGeographic, "layerName": layer.name, "layerType": layer.type, "sourceType": p.sourceType || layer.sourceType || "unknown" }
                                    });
                                    return; // continue to next polygon in layer.polygons.forEach
                                }

                                if (firstPoint[0] !== lastPoint[0] || firstPoint[1] !== lastPoint[1]) {
                                    coordinates.push([...firstPoint]); 
                                }
                            } else {
                                console.warn(`Polygon ${p.id} in layer ${layer.name} has insufficient or invalid points, skipping its geometry.`);
                                features.push({
                                    "type": "Feature",
                                    "geometry": null, 
                                    "properties": { ...(p.properties || {}), "id": p.id, "color": p.color, "isGeographic": p.isGeographic, "layerName": layer.name, "layerType": layer.type, "sourceType": p.sourceType || layer.sourceType || "unknown" }
                                });
                                return; // continue to next polygon in layer.polygons.forEach
                            }
                            
                            // Construct properties object
                            let featureProperties = {
                                ...(p.properties || {}), // Start with existing properties from GeoJSON/DBF
                                "id": p.id,
                                "color": p.color,
                                "isGeographic": p.isGeographic,
                                "isExternal": p.isExternal || false,
                                "sourceType": p.sourceType || layer.sourceType || "unknown",
                                "layerName": layer.name,
                                "layerType": layer.type,
                                // Explicitly add fields that might be directly on 'p' if not in 'p.properties'
                                "Farmer_Name": p.Farmer_Name || (p.properties && p.properties.Farmer_Name),
                                "Farm_Address": p.Farm_Address || (p.properties && p.properties.Farm_Address),
                                "Registered_Area": p.Registered_Area || (p.properties && p.properties.Registered_Area),
                                "Tobacco_Type": p.Tobacco_Type || (p.properties && p.properties.Tobacco_Type),
                                "Sub_type": p.Sub_type || (p.properties && p.properties.Sub_type),
                                "Variety": p.Variety || (p.properties && p.properties.Variety),
                                "Validated_Area": p.Validated_Area || (p.properties && p.properties.Validated_Area),
                                "Difference": p.Difference || (p.properties && p.properties.Difference)
                            };
                            // Remove any properties that are undefined to keep GeoJSON clean
                            Object.keys(featureProperties).forEach(key => featureProperties[key] === undefined && delete featureProperties[key]);

                            features.push({
                                "type": "Feature",
                                "geometry": { "type": "Polygon", "coordinates": [coordinates] }, 
                                "properties": featureProperties
                            });
                        });
                    }
                });

                const geojson = {
                    "type": "FeatureCollection",
                    "features": features // features array is already filtered by construction
                };

                const geojsonString = JSON.stringify(geojson, null, 2);
                // console.log("Generated GeoJSON string:", geojsonString); // For extensive debugging

                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(geojsonString);
                const a = document.createElement('a');
                a.href = dataStr;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a); // Changed from a.remove() for broader compatibility
                console.log(`GeoJSON download initiated as ${filename}`);

            } catch (error) { // Catch errors
                console.error("Error during GeoJSON download:", error);
                alert("An error occurred while trying to download the GeoJSON file. Check the console for details.");
            }
        }

        async function downloadAsShapefile() {
            // Removed outdated check: if (polygons.length === 0)
            // The check for polygonsToExport.length === 0 later is sufficient.

            loaderOverlay.classList.remove('hidden');
            loaderOverlay.querySelector('p').textContent = 'Generating Shapefile...';

            try {
                let polygonsToExport = [];
                layers.forEach(layer => {
                    if (layer.visible && layer.polygons) {
                        layer.polygons.forEach(p => {
                            // Prepare properties, prioritizing p.properties if it exists (e.g., from external layers)
                            let mergedProperties = {
                                id: p.id, // Ensure basic ID is always there
                                color: p.color,
                                isGeographic: p.isGeographic,
                                layerName: layer.name, // Add layer name
                                layerType: layer.type,
                                sourceType: p.sourceType || layer.sourceType || "unknown",
                                // Explicitly add known fields, falling back to p.properties if they exist there
                                Farmer_Name: p.Farmer_Name || (p.properties && p.properties.Farmer_Name) || "",
                                Farm_Address: p.Farm_Address || (p.properties && p.properties.Farm_Address) || "",
                                Registered_Area: p.Registered_Area || (p.properties && p.properties.Registered_Area) || 0,
                                Tobacco_Type: p.Tobacco_Type || (p.properties && p.properties.Tobacco_Type) || "",
                                Sub_type: p.Sub_type || (p.properties && p.properties.Sub_type) || "",
                                Variety: p.Variety || (p.properties && p.properties.Variety) || "",
                                Validated_Area: p.Validated_Area || (p.properties && p.properties.Validated_Area) || 0,
                                Difference: p.Difference || (p.properties && p.properties.Difference) || 0
                            };
                            // If p.properties exists, merge it carefully to avoid overwriting core fields like id, color etc.
                            // The backend /download_shapefile will ultimately decide which fields from this payload it uses.
                            if (p.properties) {
                                for (const key in p.properties) {
                                    if (!mergedProperties.hasOwnProperty(key)) { // Add if not already set by explicit fields
                                        mergedProperties[key] = p.properties[key];
                                    }
                                }
                            }
                            
                            polygonsToExport.push({
                                ...mergedProperties, // Spread all collected properties
                                points: p.points // Geometry
                            });
                        });
                    }
                });

                if (polygonsToExport.length === 0) {
                    alert("No visible polygons to download.");
                    loaderOverlay.classList.add('hidden');
                    return;
                }

                const response = await fetch(`${BACKEND_URL}/download_shapefile`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(polygonsToExport)
                });

                if (response.ok) {
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'polygons_shapefiles.zip'; 
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } else {
                    let errorMsg = `Failed to download shapefile. Status: ${response.status}`;
                    try {
                        const errorData = await response.json();
                        if (errorData && errorData.error) {
                            errorMsg = errorData.error;
                        }
                    } catch (e) {
                        errorMsg = response.statusText || errorMsg;
                    }
                    alert(errorMsg);
                }
            } catch (error) {
                console.error("Error downloading shapefile:", error);
                alert(`An error occurred: ${error.message}`);
            } finally {
                loaderOverlay.classList.add('hidden');
            }
        }

        // --- Vertex/Edge Manipulation Helpers ---
        function findClosestEdgeIndex(polygonPoints, newGeoPoint) {
            let minDistSq = Infinity;
            let insertAfterIndex = -1;
            const numPoints = polygonPoints.length;

            if (numPoints < 2) return 0; 

            for (let i = 0; i < numPoints; i++) {
                const p1 = polygonPoints[i];
                const p2 = polygonPoints[(i + 1) % numPoints]; 

                const l2 = Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2);
                if (l2 === 0) { 
                    const distSq = Math.pow(p1[0] - newGeoPoint[0], 2) + Math.pow(p1[1] - newGeoPoint[1], 2);
                    if (distSq < minDistSq) {
                        minDistSq = distSq;
                        insertAfterIndex = i;
                    }
                    continue;
                }

                let t = ((newGeoPoint[0] - p1[0]) * (p2[0] - p1[0]) + (newGeoPoint[1] - p1[1]) * (p2[1] - p1[1])) / l2;
                t = Math.max(0, Math.min(1, t)); 

                const closestPointOnSegment = [
                    p1[0] + t * (p2[0] - p1[0]),
                    p1[1] + t * (p2[1] - p1[1])
                ];

                const distToSegmentSq = Math.pow(closestPointOnSegment[0] - newGeoPoint[0], 2) + Math.pow(closestPointOnSegment[1] - newGeoPoint[1], 2);

                if (distToSegmentSq < minDistSq) {
                    minDistSq = distToSegmentSq;
                    insertAfterIndex = i;
                }
            }
            return insertAfterIndex;
        }

        function addVertexToPolygon(polygon, newPoint) { 
            if (!polygon || !polygon.points || polygon.points.length < 2) {
                 if (polygon && polygon.points) {
                    polygon.points.push(newPoint);
                 }
                return;
            }
            const insertAfterIndex = findClosestEdgeIndex(polygon.points, newPoint);
            polygon.points.splice(insertAfterIndex + 1, 0, newPoint);
        }

        // --- New Helper Functions ---
        function updateCursorBasedOnMode() {
            if (!image) return;
            if (isPanning) { 
                canvasContainer.style.cursor = 'grabbing';
                return;
            }
            if (isCtrlPressed && !isEditMode && !isDrawingBox && segmentMode !== 'point' && segmentMode !== 'box') { 
                canvasContainer.style.cursor = 'grabbing';
                canvasContainer.classList.add('panning');
                return;
            }

            canvasContainer.classList.remove('panning', 'segmenting-point', 'segmenting-box');

            if (isEditMode) {
                if (draggedVertexIndex !== null) {
                    canvasContainer.style.cursor = 'grabbing'; 
                } else if (isShiftPressed) {
                    canvasContainer.style.cursor = 'default'; 
                } else {
                    canvasContainer.style.cursor = 'default'; 
                }
            } else if (segmentMode === 'point') {
                canvasContainer.style.cursor = 'copy';
                canvasContainer.classList.add('segmenting-point');
            } else if (segmentMode === 'box') {
                canvasContainer.style.cursor = 'crosshair';
                canvasContainer.classList.add('segmenting-box');
            } else if (segmentMode === 'draw_polygon') {
                canvasContainer.style.cursor = 'crosshair';
            } else if (segmentMode === 'select') { // Added for select mode
                canvasContainer.style.cursor = 'pointer'; 
            } else { // Default fallback (should ideally not be reached if all modes handled)
                canvasContainer.style.cursor = 'grab'; 
            }
        }

        function isPointInPolygon(point, polygonVertices) { 
            if (!polygonVertices || polygonVertices.length < 3) return false;
            let x = point[0], y = point[1];
            let inside = false;
            for (let i = 0, j = polygonVertices.length - 1; i < polygonVertices.length; j = i++) {
                let xi = polygonVertices[i][0], yi = polygonVertices[i][1];
                let xj = polygonVertices[j][0], yj = polygonVertices[j][1];
                let intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function findClosestEdgeIndexForHover(pixelPolygonVertices, pixelMousePos) { 
            let minDistSq = Infinity;
            let closestEdgeStartIndex = -1;
            const numPoints = pixelPolygonVertices.length;

            if (numPoints < 2) return { minDistSq: Infinity, insertAfterIndex: -1 };

            for (let i = 0; i < numPoints; i++) {
                const p1 = pixelPolygonVertices[i]; 
                const p2 = pixelPolygonVertices[(i + 1) % numPoints]; 

                const l2 = Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);
                if (l2 === 0) { 
                    const distSq = Math.pow(p1.x - pixelMousePos.x, 2) + Math.pow(p1.y - pixelMousePos.y, 2);
                    if (distSq < minDistSq) {
                        minDistSq = distSq;
                        closestEdgeStartIndex = i;
                    }
                    continue;
                }

                let t = ((pixelMousePos.x - p1.x) * (p2.x - p1.x) + (pixelMousePos.y - p1.y) * (p2.y - p1.y)) / l2;
                t = Math.max(0, Math.min(1, t));

                const closestPointOnSegment = {
                    x: p1.x + t * (p2.x - p1.x),
                    y: p1.y + t * (p2.y - p1.y)
                };

                const distToSegmentSq = Math.pow(closestPointOnSegment.x - pixelMousePos.x, 2) + Math.pow(closestPointOnSegment.y - pixelMousePos.y, 2);

                if (distToSegmentSq < minDistSq) {
                    minDistSq = distToSegmentSq;
                    closestEdgeStartIndex = i;
                }
            }
            return { minDistSq, insertAfterIndex: closestEdgeStartIndex };
        }

        async function handleDoubleClick(e) { // Made async
            if (!image || layers.every(l => !l.polygons || l.polygons.length === 0)) return;

            // If already in edit mode, and the double click is on the selected polygon, do nothing.
            // Or, more generally, if in edit mode, perhaps double click should do nothing to avoid re-triggering.
            if (isEditMode) { // MODIFICATION: If already in edit mode, ignore further double clicks for starting edit mode
                console.log("Edit mode already active, double-click ignored for starting new edit session.");
                // Allow double click to potentially do something else if needed *within* edit mode later,
                // but for now, it prevents re-triggering the find-polygon-to-edit logic.
                return; 
            }

            const { x: canvasX, y: canvasY } = getMousePosOnCanvas(e);
            const previewX = (canvasX - transform.x) / transform.scale;
            const previewY = (canvasY - transform.y) / transform.scale;

            const clickedPoint = previewPixelToGeo(previewX, previewY);

            if (!clickedPoint) return;

            let clickedPolygon = null;
            // Iterate backwards through layers (to get top-most layer first if drawn in order)
            // And then backwards through polygons in that layer
            layerLoop:
            for (let i = layers.length - 1; i >= 0; i--) {
                const layer = layers[i];
                if (!layer.visible || layer.type === 'external') continue; // Only allow editing of non-external, visible layers

                for (let j = layer.polygons.length - 1; j >= 0; j--) {
                    const poly = layer.polygons[j];
                    // Ensure poly.points is valid before checking
                    if (poly.points && poly.points.length >=3 && isPointInPolygon(clickedPoint, poly.points)) {
                        clickedPolygon = poly; // We found our polygon
                        // Store layer info with the polygon for editing context if needed, or pass layer itself
                        // For now, enterEditModeForPolygon will receive the polygon object directly.
                        // We might need to enhance selectedPolygonForEdit later if complex layer interactions are needed.
                        break layerLoop; // Exit both loops
                    }
                }
            }

            if (clickedPolygon) {
                enterEditModeForPolygon(clickedPolygon); // clickedPolygon is the direct object reference
            }
        }

        async function enterEditModeForPolygon(polygonToEdit) { // Made async
            if (!polygonToEdit) return;

            // If already in edit mode with a different polygon, exit that first
            if (isEditMode && selectedPolygonForEdit && selectedPolygonForEdit.id !== polygonToEdit.id) {
                await exitEditMode(true); // Save changes for the previous polygon
            } else if (isEditMode && selectedPolygonForEdit && selectedPolygonForEdit.id === polygonToEdit.id) {
                console.log("Already editing this polygon.");
                return; // Already editing this one, do nothing.
            }
            
            // NEW: If starting to edit a polygon, and a *different* polygon was selected for inspection, clear that inspection.
            if (selectedPolygonIdForInspection !== null && selectedPolygonIdForInspection !== polygonToEdit.id) {
                console.log(`Clearing inspection selection from polygon ${selectedPolygonIdForInspection} as polygon ${polygonToEdit.id} is entering edit mode.`);
                selectedPolygonIdForInspection = null;
                // updatePolygonList(); // Not strictly needed here, will be updated by subsequent draw/update calls
            }
            // If polygonToEdit was the one selected for inspection, selectedPolygonIdForInspection remains, 
            // but its visual highlight will be superseded by edit highlight, which is handled by drawing logic.

            isEditMode = true;
            selectedPolygonForEdit = polygonToEdit;
            
            // Deep copy points for potential revert/cancel
            originalPolygonPoints = JSON.parse(JSON.stringify(selectedPolygonForEdit.points));
            if (selectedPolygonForEdit.isGcpDerived && selectedPolygonForEdit.pixelPoints) {
                originalPixelPoints = JSON.parse(JSON.stringify(selectedPolygonForEdit.pixelPoints));
            } else {
                originalPixelPoints = null; // Ensure it's reset if not applicable
            }

            canvasContainer.classList.remove('segmenting-point', 'segmenting-box');
            updateCursorBasedOnMode(); 

            tempPoints = []; tempBox = null; currentManualPolygonPoints = [];

            console.log("Entering edit mode for polygon:", selectedPolygonForEdit.id);

            samPromptButtons.classList.add('hidden');
            editModeButtons.classList.remove('hidden');
            editModeInstructions.classList.remove('hidden');
            pointInstructions.classList.add('hidden');
            boxInstructions.classList.add('hidden');
            drawPolygonInstructions.classList.add('hidden'); 
            segmentControls.classList.remove('border-slate-200');
            segmentControls.classList.add('border-blue-300', 'ring-1', 'ring-blue-300');

            draw();
            // Highlight in list
            document.querySelectorAll('#polygon-list li').forEach(item => item.classList.remove('ring-2', 'ring-indigo-500', 'bg-indigo-50'));
            const listItem = Array.from(document.querySelectorAll('#polygon-list li button.edit-btn'))
                                .find(btn => parseInt(btn.dataset.id) === polygonToEdit.id);
            if (listItem) {
                listItem.closest('li').classList.add('ring-2', 'ring-indigo-500', 'bg-indigo-50');
            }
        }

        // --- GCP Specific Functions ---
        function toggleGcpPlacementMode() {
            isGcpPlacementMode = !isGcpPlacementMode;
            if (isGcpPlacementMode) {
                startGcpPlacementBtn.textContent = "Cancel GCP Placement";
                startGcpPlacementBtn.classList.replace('bg-indigo-600', 'bg-yellow-600');
                gcpInfoPanel.classList.remove('hidden');
                updateGcpPlacementStatus();
                // Add click listener to the map
                if (googleMap) {
                    gcpMapClickListener = googleMap.addListener('click', handleGcpMapClick);
                }
            } else {
                startGcpPlacementBtn.textContent = "Start GCP Placement";
                startGcpPlacementBtn.classList.replace('bg-yellow-600', 'bg-indigo-600');
                gcpInfoPanel.classList.add('hidden');
                // Remove click listener
                if (gcpMapClickListener) {
                    google.maps.event.removeListener(gcpMapClickListener);
                    gcpMapClickListener = null;
                }
            }
        }

        function handleGcpMapClick(event) {
            if (!isGcpPlacementMode || gcpPoints.length >= 4) return;

            const latLng = event.latLng;
            const marker = new google.maps.Marker({
                position: latLng,
                map: googleMap,
                label: (gcpPoints.length + 1).toString(),
                draggable: true,
            });

            const gcp = { geo: latLng, marker: marker };
            gcpPoints.push(gcp);

            // Add listener for when a marker is dragged
            marker.addListener('dragend', () => {
                const index = gcpPoints.findIndex(p => p.marker === marker);
                if (index !== -1) {
                    gcpPoints[index].geo = marker.getPosition();
                    updateGcpCoordinatesDisplay();
                }
            });

            updateGcpPlacementStatus();
            updateGcpCoordinatesDisplay();
        }

        function updateGcpPlacementStatus() {
            const pointsNeeded = 4 - gcpPoints.length;
            if (pointsNeeded > 0) {
                gcpPlacementStatus.textContent = `Click on the map to place GCP #${gcpPoints.length + 1}... (${pointsNeeded} more needed)`;
            } else {
                gcpPlacementStatus.textContent = "All 4 GCPs placed. You can now capture the view.";
                gcpPlacementStatus.classList.add('text-green-600');
            }
        }
        
        function updateGcpCoordinatesDisplay() {
            gcpCoordinatesDisplay.innerHTML = '';
            gcpPoints.forEach((gcp, index) => {
                const div = document.createElement('div');
                div.className = 'p-1 bg-slate-100 dark:bg-slate-600 rounded';
                div.innerHTML = `<b>GCP ${index + 1}:</b> Lon: ${gcp.geo.lng().toFixed(6)}, Lat: ${gcp.geo.lat().toFixed(6)}`;
                gcpCoordinatesDisplay.appendChild(div);
            });
        }

        function clearGCPs() {
            gcpPoints.forEach(gcp => gcp.marker.setMap(null));
            gcpPoints = [];
            updateGcpPlacementStatus();
            updateGcpCoordinatesDisplay();
        }

        function downloadGCPFile() {
            if (!currentSnapshotGCPData || !currentSnapshotGCPData.pixel_gcps || currentSnapshotGCPData.pixel_gcps.length < 4) {
                alert("No valid GCP data available for the current snapshot to download.");
                return;
            }

            let gcpFileContent = "mapX,mapY,pixelX,pixelY,enable\n";
            for (let i = 0; i < 4; i++) {
                const geo = currentSnapshotGCPData.geo_gcps[i]; // [lon, lat]
                const pixel = currentSnapshotGCPData.pixel_gcps[i]; // [x, y]
                gcpFileContent += `${geo[0]},${geo[1]},${pixel[0]},${pixel[1]},1\n`;
            }

            const dataStr = "data:text/csv;charset=utf-8," + encodeURIComponent(gcpFileContent);
            const a = document.createElement('a');
            a.href = dataStr;
            a.download = "snapshot_gcps.points"; // Changed extension to .points
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a); // Using removeChild for wider compatibility
        }


        function isEffectivelyIdentity(transformParams, epsilon = 1e-6) {
            if (!transformParams || transformParams.length < 6) return false;
            const [A, B, C, D, E, F] = transformParams;
            return (
                Math.abs(A - 1) < epsilon &&
                Math.abs(B - 0) < epsilon &&
                Math.abs(D - 0) < epsilon &&
                Math.abs(E - 1) < epsilon 
            );
        }

        // --- Symbology Editor Functions ---
        function getRgbaAlpha(rgbaString) { 
            if (!rgbaString) return 1.0;
            const match = rgbaString.match(/rgba?\(.+,\s*([0-9.]+)\)/);
            return match && match[1] ? parseFloat(match[1]) : 1.0;
        }

        function setRgbaAlpha(rgbaString, newAlpha) { 
            if (!rgbaString) return `rgba(0,0,0,${newAlpha})`; // Default to black if input is bad
            if (rgbaString.startsWith('rgba')) {
                return rgbaString.replace(/,\s*[0-9.]+\)$/, `,${newAlpha})`);
            } else if (rgbaString.startsWith('rgb')) {
                return rgbaString.replace('rgb', 'rgba').replace(')', `,${newAlpha})`);
            }
            // If it's hex or named color, this simple replacement won't work well.
            // For now, this function assumes input is 'rgb(...)' or 'rgba(...)'.
            // A full color parsing library would be better for hex/named colors.
            console.warn("setRgbaAlpha: Input was not a recognized rgba or rgb string:", rgbaString);
            return `rgba(0,0,0,${newAlpha})`; // Fallback
        }

        function rgbaToHex(rgba) { // Simpler version for color picker, ignores alpha
            if (!rgba) return '#000000';
            const parts = rgba.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
            if (!parts) return '#000000';
            const r = parseInt(parts[1]).toString(16).padStart(2, '0');
            const g = parseInt(parts[2]).toString(16).padStart(2, '0');
            const b = parseInt(parts[3]).toString(16).padStart(2, '0');
            return `#${r}${g}${b}`;
        }
        
        function hexToRgba(hex, alpha = 1.0) {
            if (!hex.startsWith('#')) hex = '#000000'; // Fallback for invalid hex
            let r = parseInt(hex.slice(1, 3), 16) || 0;
            let g = parseInt(hex.slice(3, 5), 16) || 0;
            let b = parseInt(hex.slice(5, 7), 16) || 0;
            return `rgba(${r},${g},${b},${alpha})`;
        }
        
        function openSymbologyEditor(layerId) {
            currentSymbologyEditLayerId = layerId;
            const layer = layers.find(l => l.id === layerId);
            if (!layer) { 
                console.error("Symbology: Layer not found", layerId); 
                return; 
            }

            symbologyLayerNameSpan.textContent = layer.name;
            // Ensure layer.symbology exists, defaulting to a basic single symbol structure if not.
            const sym = layer.symbology || { 
                type: 'singleSymbol', 
                fillColor: 'rgba(0,0,255,0.4)', 
                strokeColor: 'rgba(0,0,200,1)', 
                strokeWidth: 1, 
                strokeDashArray: [] 
            };

            // Force to single symbol mode as categorized is removed
            symbologyTypeSelect.value = 'singleSymbol'; 
            symbologySettingsSingleSymbolDiv.classList.remove('hidden');
            const categorizedSettingsDiv = document.getElementById('symbology-settings-categorized');
            if (categorizedSettingsDiv) categorizedSettingsDiv.classList.add('hidden'); // Hide if it still exists in DOM


            // Populate single symbol controls
            const defaultInitialSym = layers[0].symbology; // Fallback for completely new/uninitialized layers
            symbologyFillColorRgbaInput.value = sym.fillColor || defaultInitialSym.fillColor;
            symbologyFillColorPicker.value = rgbaToHex(sym.fillColor || defaultInitialSym.fillColor);
            symbologyStrokeColorRgbaInput.value = sym.strokeColor || defaultInitialSym.strokeColor;
            symbologyStrokeColorPicker.value = rgbaToHex(sym.strokeColor || defaultInitialSym.strokeColor);
            symbologyStrokeWidthInput.value = sym.strokeWidth === undefined ? (defaultInitialSym.strokeWidth === undefined ? 1 : defaultInitialSym.strokeWidth) : sym.strokeWidth;
            symbologyStrokeDashSelect.value = (sym.strokeDashArray || defaultInitialSym.strokeDashArray || []).join(',');
            
            symbologyModal.classList.remove('hidden');
        }

        function closeSymbologyEditor() {
            symbologyModal.classList.add('hidden');
            currentSymbologyEditLayerId = null;
        }

        function applySymbologyChanges() {
            if (!currentSymbologyEditLayerId) return;
            const layer = layers.find(l => l.id === currentSymbologyEditLayerId);
            if (!layer) return;

            // Type is always singleSymbol now
            const symbolType = 'singleSymbol'; 

            const newFillRgba = symbologyFillColorRgbaInput.value || 'rgba(0,0,255,0.4)';
            const newStrokeRgba = symbologyStrokeColorRgbaInput.value || 'rgba(0,0,200,1)';
            
            // Build a clean symbology object for single symbol
            layer.symbology = {
                type: 'singleSymbol',
                fillColor: newFillRgba,
                strokeColor: newStrokeRgba,
                strokeWidth: parseFloat(symbologyStrokeWidthInput.value) || 0,
                strokeDashArray: parseStrokeDashArray(symbologyStrokeDashSelect.value)
                // field, categories, defaultSymbol are removed
            };
            
            console.log("Applied symbology changes (single symbol only) for layer:", layer.id, JSON.parse(JSON.stringify(layer.symbology)));
            draw(); 
            updateLayerPane(); // To refresh any layer list display that might show symbology
            
            // Update Google Map style if applicable
            if (googleMap && imageSourceTypeSelect.value === '3dmap' && layer.mapDataGeoJson && layer.type === 'external') {
                 googleMap.data.forEach(feature => {
                    if (feature.getProperty('geoSegmenterLayerId') === layer.id) { 
                         googleMap.data.overrideStyle(feature, {
                            fillColor: layer.symbology.fillColor, 
                            strokeColor: layer.symbology.strokeColor, 
                            strokeWeight: layer.symbology.strokeWidth,
                            fillOpacity: getRgbaAlpha(layer.symbology.fillColor), // Extract alpha for map.data
                            strokeOpacity: getRgbaAlpha(layer.symbology.strokeColor), // Extract alpha
                         });
                    }
                });
            }
        }
        
        function parseStrokeDashArray(stringValue) {
            if (!stringValue || stringValue.trim() === "") return [];
            return stringValue.split(',').map(n => parseFloat(n.trim())).filter(n => !isNaN(n) && n >= 0);
        }

        // Removed populateCategorizedFieldSelect, handleClassifyCategories, and renderCategorySymbolList functions
        // as they are no longer needed after removing categorized symbology.

        // --- End Symbology Editor Functions ---

        //Final Program
        // init(); // Direct call removed
        document.addEventListener('DOMContentLoaded', init); // Call init after DOM is fully loaded
    </script>

    <!-- Symbology Editor Modal -->
    <div id="symbology-editor-modal" class="hidden fixed inset-0 bg-slate-600 bg-opacity-50 overflow-y-auto h-full w-full z-40 flex items-center justify-center">
        <div class="relative mx-auto p-5 border w-full max-w-lg shadow-lg rounded-md bg-white dark:bg-slate-800">
            <!-- Modal Header -->
            <div class="flex justify-between items-center pb-3 border-b dark:border-slate-700">
                <h3 class="text-lg font-semibold text-slate-900 dark:text-slate-100">Edit Symbology - <span id="symbology-editor-layer-name">[Layer Name]</span></h3>
                <button id="symbology-editor-close-btn-header" class="p-1 rounded-md hover:bg-slate-200 dark:hover:bg-slate-700">
                    <svg class="w-5 h-5 text-slate-600 dark:text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>

            <!-- Modal Body -->
            <div class="py-4 space-y-4 text-sm">
                <div>
                    <label class="block text-slate-700 dark:text-slate-300 mb-1">Symbol Type:</label>
                    <select id="symbology-type-select" class="w-full p-2 border border-slate-300 rounded-md dark:bg-slate-700 dark:border-slate-600 dark:text-slate-200">
                        <option value="singleSymbol" selected>Single Symbol</option>
                        <!-- <option value="graduated">Graduated</option> -->
                    </select>
                </div>

                <div id="symbology-settings-singleSymbol" class="space-y-3 p-3 border rounded-md dark:border-slate-700 bg-slate-50 dark:bg-slate-700/30">
                    <h4 class="text-md font-medium text-slate-800 dark:text-slate-200 border-b pb-1 dark:border-slate-600">Single Symbol Settings</h4>
                    <!-- Fill Settings -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3 items-center">
                        <div>
                            <label for="symbology-fill-color-picker" class="block text-xs font-medium text-slate-700 dark:text-slate-300">Fill Color:</label>
                            <input type="color" id="symbology-fill-color-picker" class="h-8 w-full p-0 border-none rounded">
                        </div>
                        <div>
                             <label for="symbology-fill-color-rgba" class="block text-xs font-medium text-slate-700 dark:text-slate-300">RGBA Value:</label>
                            <input type="text" id="symbology-fill-color-rgba" placeholder="rgba(r,g,b,a)" class="w-full p-1.5 border border-slate-300 rounded-md text-xs dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200">
                        </div>
                    </div>

                    <!-- Stroke Settings -->
                     <div class="grid grid-cols-1 md:grid-cols-2 gap-3 items-center">
                        <div>
                            <label for="symbology-stroke-color-picker" class="block text-xs font-medium text-slate-700 dark:text-slate-300">Stroke Color:</label>
                            <input type="color" id="symbology-stroke-color-picker" class="h-8 w-full p-0 border-none rounded">
                        </div>
                        <div>
                            <label for="symbology-stroke-color-rgba" class="block text-xs font-medium text-slate-700 dark:text-slate-300">RGBA Value:</label>
                            <input type="text" id="symbology-stroke-color-rgba" placeholder="rgba(r,g,b,a)" class="w-full p-1.5 border border-slate-300 rounded-md text-xs dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200">
                        </div>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3 items-center">
                        <div>
                            <label for="symbology-stroke-width" class="block text-xs font-medium text-slate-700 dark:text-slate-300">Stroke Width (px):</label>
                            <input type="number" id="symbology-stroke-width" min="0" step="0.1" value="1" class="w-full p-1.5 border border-slate-300 rounded-md text-xs dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200">
                        </div>
                        <div>
                            <label for="symbology-stroke-dash" class="block text-xs font-medium text-slate-700 dark:text-slate-300">Stroke Style:</label>
                            <select id="symbology-stroke-dash" class="w-full p-1.5 border border-slate-300 rounded-md text-xs dark:bg-slate-600 dark:border-slate-500 dark:text-slate-200">
                                <option value="">Solid</option>
                                <option value="5,5">Dashed (5,5)</option>
                                <option value="1,5">Dotted (1,5)</option>
                                <option value="10,5,2,5">Dash-Dot (10,5,2,5)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Categorized Symbol Settings DIV is removed -->

                <div id="symbology-settings-graduated" class="hidden space-y-3 p-3 border rounded-md dark:border-slate-600">Graduated settings UI here... (Not yet implemented)</div>
            </div>

            <!-- Modal Footer -->
            <div class="flex justify-end pt-4 border-t dark:border-slate-700 space-x-2">
                <button id="symbology-editor-cancel-btn" class="px-4 py-2 bg-slate-200 text-slate-800 rounded-md hover:bg-slate-300 dark:bg-slate-600 dark:text-slate-200 dark:hover:bg-slate-500">Cancel</button>
                <button id="symbology-editor-apply-btn" class="px-4 py-2 bg-yellow-500 text-white rounded-md hover:bg-yellow-600">Apply</button>
                <button id="symbology-editor-ok-btn" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">OK</button>
            </div>
        </div>
    </div>

</body>
</html>
